#  求职

## 学习

### JAVA

#### 基础
  - [ ] 面向对象
      - [ ] 封装：封装就是，将对象的“属性”和“行为”抽象出来，包装到一个类中；
      - [ ] 继承：继承就是将具有相同“属性”和“行为”的对象抽象出来，并包装成一个父类；
      - [ ] 多态：
- [x] Java Lambda表达式：只能用于重载interface的情况，使用lambda表达式替代构造方法，可以省略接口的方法名和参数类型；lambda表达式可以生成匿名类，不对类进行声明而直接构造对象。
- [x] Java枚举：枚举类型（比如Day）类似与抽象类，枚举类型的实际值（比如Monday，Tuesday）类似与子类，enum具有构造函数，但是只有一个实例，多个相同值的enum引用指向同一个对象。
- [x] Java反射：反射的优点，运行期类型的判断，动态加载类，动态绑定，提高代码的灵活度；反射的缺点，性能较慢，需要向jvm做一系列的解释操作，同时增加了类的安全隐患（封装会被破坏）。
- [x] Java动态代理：对于jvm来说，动态代理是在运行时动态生成类字节码，并加载到jvm中的；Spring AOP、RPC这两个框架的实现都依赖了动态代理；动态代理的优点，更加灵活，可以不实现被代理类的接口，直接实现代理（CGLIB），并且当被代理类新增方法时，使用动态代理不需修改代理对象，在jvm层面，动态代理不需要对源码、字节码进行修改，而是在运行时动态生成类字节码。
- [x] JDK动态代理机制：其具体实现，使用到了反射，根据被代理类实现的接口，构建具有相同接口的代理类，两个类可通过反射来执行相同的方法（方法名、参数列表、方法签名均相同），实际上是调用了代理类对象的方法，然后代理类对象调用了被代理类对象的相同方法；该方法的致命问题是，它只能代理实现了接口的类；
- [x] CGLIB动态代理机制：CGLIB是一种基于ASM的代码生成工具库；该方法可以解决JDK动态代理存在的缺陷；CGLIB实现动态代理，不需要构建代理类，而是使用代理增强类Enhancer对被代理类进行处理，使用方法拦截器MethodInterceptor捕获被代理类的方法调用，并对其做自定义的修改；使用该方法，相当于生成了匿名代理类的对象。
#### Java集合框架

##### Collection

- [ ] 

##### List
- [ ] List的元素是有序、可重复的，Set的元素是无序、不重复的，Map使用键值对（key-value）进行存储，key是无序不重复的，value是无序可重复的；
- [ ] 集合的线程安全性：
- [ ] 定制化排序：
- [ ] 无序性与不可重复性
  - [ ] 无序性：无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。
  - [ ] 不可重复性：不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。
- [ ] Arrays.asList()方法

##### Map接口
- [ ] Map类使用了内部类Map.Entry对象来存储键值对；

AbstractMap抽象类

- [ ] containKey、get、remove方法实现：使用迭代器entrySet().iterator()，对Map的所有key进行遍历；AbstractMap对null key做了特殊处理。

###### HashMap与HashTable：

- [ ] Capacity：容量，bucket的数量，默认为16，即拉链法中的数组的长度；

- [ ] Load Factor：负载因子，默认为0.75，当map中的元素数量大于（Capacity*Load Factor）时，bucket的数量将调整为原先的2倍；

- [ ] threshold：临界值，即（Capacity*Load Factor）的值。

- [ ] 负载因子为什么默认是0.75：

  - [ ] 0.75介于0.5和1之间，是比较好的折中；
  - [ ] 如果负载因子较小，空间损耗会较高，比如0.5，那么每当bucket table被使用到一半时就会扩容，那么至少有一半的空间是未被占用的；
  - [ ] 如果负载因子较高，时间损耗会较高，get、put所需的时间开销会较大；比如负载因子为1时，当size与capacity相同时才会进行扩容，那么必然会存在较多的hash冲突情况。

- [ ] 扰动方法 static final int hash(Object key)

  - [ ] 为了防止一些实现比较差的hashCode()方法，HashMap使用扰动方法来减少hash碰撞；

  - [ ] jdk 1.8：

    ```java
        static final int hash(Object key) {
          int h;
          // key.hashCode()：返回散列值也就是hashcode
          // ^ ：按位异或
          // >>>:无符号右移，忽略符号位，空位都以0补齐
          return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
      }
    ```

  - [ ] jdk 1.7

    ```java
    static int hash(int h) {
        // This function ensures that hashCodes that differ only by
        // constant multiples at each bit position have a bounded
        // number of collisions (approximately 8 at default load factor).
    
        h ^= (h >>> 20) ^ (h >>> 12);
        return h ^ (h >>> 7) ^ (h >>> 4);
    }
    ```

- [ ] 都是基于Map实现的，但是HashMap继承自抽象类AbstractMap，而HashTable继承自抽象类Dictionary（该区别意义不大，应为Dictionaty已经被废弃了）；

- [ ] null key 和 null value 的支持：HashMap支持null为key值，以及null为value，而HashTable在遇到null时，会抛出NullPointerException异常，这是因为HashMap对null进行了特殊处理，将null的hash设置为0；

- [ ] 线程安全性：HashMap是非线程安全的，HashTable是线程安全的，因为HashTable内部的方法都经过synchronized修饰；

- [ ] 效率：由于线程安全的问题，HashMap的效率要比HashTable高；

- [ ] 注意，HashTable基本已经被淘汰，如果要是用线程安全的Map，请使用ConcurrentHashMap；

- [ ] 扩容：HashTable默认初始值为11，扩充时容量变为2n+1，若给定了容量初始值，则容量变为给定初始值；HashMap默认的初始值为16，每次扩容将容量扩充为原来的2倍，若给定初始值，则将初始值扩充为2的幂次方大小，这是为bootstraping机制做保证；

- [ ] HashMap为什么容量为2的幂次，并且在扩充时选择乘2：

  - [ ] 使用位运算可以提高性能；
  - [ ] 判断元素在table中的位置，使用 **(n - 1) & hash** ，此处的n为2的幂次，等同于**hash%n**，不过效率更高，约能提升10倍；
  
- [ ] HashMap拉链法：

  - [ ] 当链表长度大于8时，先判断bucketTable的size是否大于64，若小于64则先对bucketTable进行数组扩容；
  - [ ] 当链表长度大于8，并且bucketTable的size是大于64时，将链表转换为红黑树（TreeNode）；

- [ ] 底层数据结构：jdk1.8以后，HashMap在解决冲突时，现将拉链法的链表的长度阈值设置为8，当超过该阈值时进行扩容
###### TreeMap
- [ ] 不是线程安全的

- [ ] TreeMap并实现了NavigableMap接口，而NavigableMap接口实现了SortedMap接口；它的keyset是有序的，使用迭代器进行遍历时，可以根据key的排序顺序进行输出。

- [ ] 使用TreeMap时，key值必须是实现了Comparable接口，或者对TreeMap中的compareTo方法进行重写。

- [ ] 底层使用红黑树实现静态内部类TreeMap.Entry，通过根节点TreeMap.Entry root来访问所有的entry对象。

- [ ] get方法的实现：调用getEntry内部方法，通过对红黑树TreeMap.Entry root的访问，实现在log(n)时间内get到目标entry。

- [ ] containsKey方法实现：通过get方法，判断是否能够get到目标entry，复杂度O(log(n));

- [ ] containsValue方法实现：遍历红黑树，查询是否有目标Value，复杂度O(n)

###### ConcurrentHashMap

 - [ ] ConcurrentHashMap是一种线程安全的Map类型，底层使用了拉链法；
 - [ ] 保证线程安全的方式：
    - [ ] jdk.17:对bucketTable使用了分段加锁的方法，保证并发的线程安全性；
    - [ ] jdk1.8:摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作；
    - [ ] synchronized 和 CAS的方式，只锁定当前链表或者红黑树的首节点，相当于对bucketTable数组中的每一个对象都加锁；
 - [ ] 与HashTable的对比：HashTable只使用了一把锁，效率非常低下；

##### Set

- [ ] HashSet：
  - [ ]  Set 接口的主要实现类 ，HashSet 的底层是 HashMap，线程不安全的，可以存储 null 值；
  - [ ] 直接通过HashMap实现，通过内部的HashMap成员HashMap<E,Object> map 来访问HashMap的方法；
  - [ ] HashSet实现Map时，只有key，没有value，value是HashSet类的静态私有成员private static final Object PRESENT = new Object();
- [ ] LinkedHashSet：HashSet 的子类，能够按照添加的顺序遍历；
- [ ] TreeSet ：底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。

##### Iterator
- [ ] forEach循环：增强型for循环

```java
List<String> list = new ArrayList<String>();
for(String e : list){
	// TODO
}
```
本质是使用了迭代器Iterator对Collection中的对象进行遍历。

- [ ]  fail-fast机制（快速失败）：一种集合的错误检测机制，当使用迭代器遍历集合时，若集合被修改，则会触发fail-fast机制，抛出ConcurrentModificationException异常；另外，在单线程下，如果在遍历过程中对集合对象的内容进行了修改的话也会触发 fail-fast 机制。
- [ ]  fail-safe机制（安全失败）：采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。所以，在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常。

#### JVM

- [ ] 对象的引用存放的栈内存中，对象的实例存放在堆内存中；

#### Java多线程

#### Java注解
#### Java内部类、匿名内部类
- [ ] jvm
- [ ] Sql索引
- [ ] Spring、Spring boot
- [ ] Spring AOP：如果目标对象继承了接口，那么默认使用JDK动态代理，否则采用CGLIB动态代理；
- [ ] 设计模式
### 计算机网络
#### 五层协议体系结构
- [ ] 自顶向下：1）应用层；2）运输层；3）网络层；4）数据链路层；4）物理层
- [ ] 1）应用层（application layer）
  - [ ] 应用层的任务是通过应用进程之间的交互来完成特定的网络应用；
  - [ ] 应用层常见协议：
    - [ ] 使用TCP
      - [ ] 电子邮件系统
      - [ ] http 超文本传输协议 默认端口80
      - [ ] FTP 文件传输协议 端口20/21
    - [ ] 使用UDP
      - [ ] 域名系统DNS 端口53
      - [ ] DHCP 动态主机配置协议 给局域网用户分配IP地址
- [ ] 2）运输层（transport layer）
  - [ ] 保证端到端的传输：运输层为两台主机进程之间的通信提供通用的数据传输服务
    - [ ] 运输层主要的协议：
      - [ ] 1）TCP 传输控制协议，提供面向连接的可靠传输服务。
      - [ ] 2） UDP 用户数据协议，提供无连接的高效传输服务，不保证数据传输的可靠性。
- [ ] 3）网络层
  - [ ] 功能
    - [ ] 1）将运输层产生的报文（TPC报文段，UDP用户数据报），分为IP数据报，分组分包发送；
    - [ ] 2）子网控制，网间路由，选择合适的数据传送方向；
  - [ ] 计算机网络中的两台计算机之间的通信，可能经过多个数据链路，可能会通过多个通信子网层；网络层的任务是，选择合适的网间路由和交换结点，确保数据及时传送；发送数据时，网络层将运输层产生的报文段或者用户数据报，封装成分组和包进行传送；由于TCP\IP协议中，网络层使用了IP协议，因此分组也叫IP数据报；
- [ ] 4）数据链路层（data link layer)
  - [ ] 物理寻址：负责相邻接点之间的数据传输；
  - [ ] 数据链路层将网络层交下来的IP数据报，组装成帧，每一帧包含数据信息、必要的控制信息（同步信息、地址信息、差错控制）；
  - [ ] 数据链路层还会进行差错控制，将出现差错的帧丢弃，或者对其进行纠错；
- [ ] 5）物理层
- [ ]  TCP 三次握手 四次挥手
  - [ ] 三次握手
    - [ ] 目的：建立可靠的连接
    - [ ] 连接标准，怎样算可靠：发送方和接收方，都要确认自己和对方的发送正常、接受正常；
    - [ ] 过程：
      - [ ] 1）发送方发送SYN（synchronous请求同步）
      - [ ] 2）接收方收到，接收方确认自己接受正常，发送方发送正常；接收方向发送方发送SYN/ACK（acknowledgement 确认）；
      - [ ] 3）发送方确认自己发送、接受正常，接收方发送、接受正常；发送方向接收方发送ACK；
      - [ ] 4）接收方确认发送方接受正常，建立连接；
  - [ ] 四次挥手
    - [ ] 目的：确认连接双方都结束连接
    - [ ] 1）主动结束方，向被动结束方发送FIN（finish结束）；
    - [ ] 2）被动方收到，向主动方发送ACK；主动方等待被动方发送FIN；
    - [ ] 3）被动方发送FIN；
    - [ ] 4）主动方收到，向被动方发送ACK，成功释放链接；
- [ ] TCP如何保证可靠传输
  - [ ] TCP将数据分段 数据块大小较为合适
  - [ ] TCP将每一个包标号 接收方对收到的数据包进行排序 把有序数据传送给应用层
  - [ ] 校验和 丢弃校验出错的数据
  - [ ] 丢弃重复的数据
  - [ ] 流量控制：为了防止接收端的缓冲空间不足，当接收端来不及处理数据时，提示发送方降低发送的速率，防止包丢失；
  - [ ] 拥塞控制：当网络拥塞时，减少数据的发送；
  - [ ] ARQ协议：为了实现可靠的传输，每发完一个分组就停止发送，等待对方确认，收到确认后再发送下一个分组；
  - [ ] 超时重传：当TCP发送一个分组后，在规定时间内没有收到对方的确认信息，则重发这个报文段；
- [ ] ARQ协议 自动重传请求（Automatic Repeat-reQuest）
  - [ ] OSI模型中的数据链路层、传输层的错误纠正协议之一；它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输；
  - [ ] 停止等待ARQ协议
    - [ ] 为了实现可靠传输，当TCP发送一个分组后，在规定时间内没有收到对方的确认信息，则重发这个报文段；
    - [ ] 若接收方收到重复分组，则丢弃，但是仍然要发送ACK确认；
    - [ ] 优点：简单
    - [ ] 缺点：信道利用率低 等待时间长
  - [ ] 连续ARQ协议
    - [ ] 发送方维持一个发送窗口，但凡位于发送窗口内的分组，可以连续发送出去，而不需要等待对方确认；接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表示到这个分组为止的所有分组都已经正确收到；
    - [ ] 接收方如果接收到了不连续的分组，比如1,2,3,5,分组4丢失了，那么接收方将会发送一个分组3的ACK确认信息；
    - [ ] 优点：信道利用率高，容易实现，即使确认丢失，也不必重传；
    - [ ] 缺点：不能反映接收方已经正确受到的所有分组信息；比如分组4丢失了，而分组5,6均未丢失，发送方仍然会将4,5,6重传；
- [ ] 滑动窗口和流量控制
  - [ ] TCP使用滑动窗口进行流量控制，流量控制是为了控制发送方速率，保证接收方来得及接受；接收方发送的ACK确认报文中的窗口字段信息，可以用来控制发送方的窗口大小，从而影响发送方的发送速率；将窗口字段设置为0，则发送方不能发送数据；
- [ ] 拥塞控制
  - [ ] 
### 数据结构

- [ ] 平衡二叉树
  - [ ] AVL和红黑树的区别
    - [ ] AVL数是严格的平衡二叉树，每个节点的左子树与右子树的高度差小于等于1；而红黑树是弱平衡二叉树，确保没有一条路径比其他路径长出两倍；相同节点数量的情况下，AVL树的深度比红黑树要小；
    - [ ] 红黑树的平均高度是log(n)，但是最坏情况下的高度不超过2log(n)；
    - [ ] AVL的旋转非常耗时，不适合插入与删除非常多的情况；红黑树的旋转次数少，适合插入与删除较多的情况；
    - [ ] AVL的高度比红黑树低，因此查询速度更快；

### 微服务

- [ ] 微服务解决的问题：单体地狱。如果将一个应用的多个模块，捆绑到同一个jar包（war包）中，会存在很多的问题；每个模块都在变更、迭代，导致生成的jar包非常臃肿；单个模块出现bug时，会影响到别的模块，bug难以定位；不同模块的负载是不同的，高负载的模块会对低负载模块造成影响，比如如果登录、支付功能捆绑在一起，若同一时间进行登录操作的用户过多，该模块将会占用更多的资源，导致支付模块可用的资源过少，影响性能；
- [ ] 微服务的作用：解耦合，将臃肿的单体应用程序，分解成一套较小的互联服务。
- [ ] 三大指标：高可用、高性能、高并发。
- [ ] 优点：1）解耦，将一个复杂问题转化为多个简单问题；2）独立开发，每个简单问题可以由不同的团队独立专注开发，并且不同的微服务可以使用不同的技术开发；3）独立部署，分布式部署。
- [ ] 缺点： 1）；2）微服务本身是分布式系统，整体复杂，模块间的通讯复杂，需要通过消息或者RPC进行进程间通信，模块之间的相互调用存在延迟，可能会引入新的问题；3）分区数据库，分布式事务的问题；4）测试微服务应用程序也很复杂；5）跨越多服务变更，多个服务之间具有依赖关系、启动顺序，变更时会遇到问题；6）微服务部署复杂；
- [ ] CAP定理
  - [ ] Consistency 一致性：更新操作成功并返回客户端之后，所有节点在同一时间的数据完全一致；
  - [ ] Availability 可用性：服务可用，在正常响应时间内可用；
  - [ ] Partition tolerance 分区容错性：分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。
  - [ ] CP系统，高一致系统，对数据准确性要求较高场景，金融系统通常是CP系统；
  - [ ] AP系统，高可用系统，需要保证99.999999%的时间都是可用的。

---
## 简历投递
### 已投

- [ ] 银联
- [ ] Vivo：没做笔试
- [ ] 吉比特&雷霆游戏：人才库
- [ ] 百度：笔试
- [ ] 携程
- [ ] 小红书
- [ ] 爱奇艺：笔试
- [ ] 网易互娱（杭州）
- [ ] 腾讯
- [ ] 字节跳动（HR投递）
- [ ] 万得Wind：hr面
- [ ] 触宝
- [ ] 英特尔
- [ ] 滴滴（杭州）
- [ ] 米哈游：笔试
- [ ] 招商银行（上海）
- [ ] 阿里巴巴（杭州）：笔试
- [ ] 拼多多
- [ ] 有赞（杭州）
- [ ] eBay

---
### 待投

- [ ] 交通银行
- [ ] （不投）bilibili
- [ ] 网易（杭州）
- [ ] // 阿里巴巴（杭州）
- [ ] 蘑菇街（杭州）
- [ ] 海康威视（杭州）
- [ ] 大华
- [ ] Paypal
- [ ] 思科（杭州/上海）
- [ ] 华为
