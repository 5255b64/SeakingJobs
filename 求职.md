求职

## 学习

### JAVA

#### 基础
  - [ ] 面向对象
      - [ ] 封装：封装就是，将对象的“属性”和“行为”抽象出来，包装到一个类中；
      - [ ] 继承：继承就是将具有相同“属性”和“行为”的对象抽象出来，并包装成一个父类；
      - [ ] 多态：
- [x] Java Lambda表达式：只能用于重载interface的情况，使用lambda表达式替代构造方法，可以省略接口的方法名和参数类型；lambda表达式可以生成匿名类，不对类进行声明而直接构造对象。
- [x] Java枚举：枚举类型（比如Day）类似与抽象类，枚举类型的实际值（比如Monday，Tuesday）类似与子类，enum具有构造函数，但是只有一个实例，多个相同值的enum引用指向同一个对象。
- [x] Java反射：反射的优点，运行期类型的判断，动态加载类，动态绑定，提高代码的灵活度；反射的缺点，性能较慢，需要向jvm做一系列的解释操作，同时增加了类的安全隐患（封装会被破坏）。
- [x] Java动态代理：对于jvm来说，动态代理是在运行时动态生成类字节码，并加载到jvm中的；Spring AOP、RPC这两个框架的实现都依赖了动态代理；动态代理的优点，更加灵活，可以不实现被代理类的接口，直接实现代理（CGLIB），并且当被代理类新增方法时，使用动态代理不需修改代理对象，在jvm层面，动态代理不需要对源码、字节码进行修改，而是在运行时动态生成类字节码。
- [x] JDK动态代理机制：其具体实现，使用到了反射，根据被代理类实现的接口，构建具有相同接口的代理类，两个类可通过反射来执行相同的方法（方法名、参数列表、方法签名均相同），实际上是调用了代理类对象的方法，然后代理类对象调用了被代理类对象的相同方法；该方法的致命问题是，它只能代理实现了接口的类；
- [x] CGLIB动态代理机制：CGLIB是一种基于ASM的代码生成工具库；该方法可以解决JDK动态代理存在的缺陷；CGLIB实现动态代理，不需要构建代理类，而是使用代理增强类Enhancer对被代理类进行处理，使用方法拦截器MethodInterceptor捕获被代理类的方法调用，并对其做自定义的修改；使用该方法，相当于生成了匿名代理类的对象。
#### Java集合框架

##### Collection

- [ ] 

##### List
- [ ] List的元素是有序、可重复的，Set的元素是无序、不重复的，Map使用键值对（key-value）进行存储，key是无序不重复的，value是无序可重复的；
- [ ] 集合的线程安全性：
- [ ] 定制化排序：
- [ ] 无序性与不可重复性
  - [ ] 无序性：无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。
  - [ ] 不可重复性：不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。
- [ ] Arrays.asList()方法

##### Map接口
- [ ] Map类使用了内部类Map.Entry对象来存储键值对；

AbstractMap抽象类

- [ ] containKey、get、remove方法实现：使用迭代器entrySet().iterator()，对Map的所有key进行遍历；AbstractMap对null key做了特殊处理。

###### HashMap与HashTable：

- [ ] Capacity：容量，bucket的数量，默认为16，即拉链法中的数组的长度；

- [ ] Load Factor：负载因子，默认为0.75，当map中的元素数量大于（Capacity*Load Factor）时，bucket的数量将调整为原先的2倍；

- [ ] threshold：临界值，即（Capacity*Load Factor）的值。

- [ ] 负载因子为什么默认是0.75：

  - [ ] 0.75介于0.5和1之间，是比较好的折中；
  - [ ] 如果负载因子较小，空间损耗会较高，比如0.5，那么每当bucket table被使用到一半时就会扩容，那么至少有一半的空间是未被占用的；
  - [ ] 如果负载因子较高，时间损耗会较高，get、put所需的时间开销会较大；比如负载因子为1时，当size与capacity相同时才会进行扩容，那么必然会存在较多的hash冲突情况。

- [ ] 扰动方法 static final int hash(Object key)

  - [ ] 为了防止一些实现比较差的hashCode()方法，HashMap使用扰动方法来减少hash碰撞；

  - [ ] jdk 1.8：

    ```java
        static final int hash(Object key) {
          int h;
          // key.hashCode()：返回散列值也就是hashcode
          // ^ ：按位异或
          // >>>:无符号右移，忽略符号位，空位都以0补齐
          return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
      }
    ```

  - [ ] jdk 1.7

    ```java
    static int hash(int h) {
        // This function ensures that hashCodes that differ only by
        // constant multiples at each bit position have a bounded
        // number of collisions (approximately 8 at default load factor).
    
        h ^= (h >>> 20) ^ (h >>> 12);
        return h ^ (h >>> 7) ^ (h >>> 4);
    }
    ```

- [ ] 都是基于Map实现的，但是HashMap继承自抽象类AbstractMap，而HashTable继承自抽象类Dictionary（该区别意义不大，应为Dictionaty已经被废弃了）；

- [ ] null key 和 null value 的支持：HashMap支持null为key值，以及null为value，而HashTable在遇到null时，会抛出NullPointerException异常，这是因为HashMap对null进行了特殊处理，将null的hash设置为0；

- [ ] 线程安全性：HashMap是非线程安全的，HashTable是线程安全的，因为HashTable内部的方法都经过synchronized修饰；

- [ ] 效率：由于线程安全的问题，HashMap的效率要比HashTable高；

- [ ] 注意，HashTable基本已经被淘汰，如果要是用线程安全的Map，请使用ConcurrentHashMap；

- [ ] 扩容：HashTable默认初始值为11，扩充时容量变为2n+1，若给定了容量初始值，则容量变为给定初始值；HashMap默认的初始值为16，每次扩容将容量扩充为原来的2倍，若给定初始值，则将初始值扩充为2的幂次方大小，这是为bootstraping机制做保证；

- [ ] HashMap为什么容量为2的幂次，并且在扩充时选择乘2：

  - [ ] 使用位运算可以提高性能；
  - [ ] 判断元素在table中的位置，使用 **(n - 1) & hash** ，此处的n为2的幂次，等同于**hash%n**，不过效率更高，约能提升10倍；
  
- [ ] HashMap拉链法：

  - [ ] 当链表长度大于8时，先判断bucketTable的size是否大于64，若小于64则先对bucketTable进行数组扩容；
  - [ ] 当链表长度大于8，并且bucketTable的size是大于64时，将链表转换为红黑树（TreeNode）；

- [ ] 底层数据结构：jdk1.8以后，HashMap在解决冲突时，现将拉链法的链表的长度阈值设置为8，当超过该阈值时进行扩容
###### TreeMap
- [ ] 不是线程安全的

- [ ] TreeMap并实现了NavigableMap接口，而NavigableMap接口实现了SortedMap接口；它的keyset是有序的，使用迭代器进行遍历时，可以根据key的排序顺序进行输出。

- [ ] 使用TreeMap时，key值必须是实现了Comparable接口，或者对TreeMap中的compareTo方法进行重写。

- [ ] 底层使用红黑树实现静态内部类TreeMap.Entry，通过根节点TreeMap.Entry root来访问所有的entry对象。

- [ ] get方法的实现：调用getEntry内部方法，通过对红黑树TreeMap.Entry root的访问，实现在log(n)时间内get到目标entry。

- [ ] containsKey方法实现：通过get方法，判断是否能够get到目标entry，复杂度O(log(n));

- [ ] containsValue方法实现：遍历红黑树，查询是否有目标Value，复杂度O(n)

###### ConcurrentHashMap

 - [ ] ConcurrentHashMap是一种线程安全的Map类型，底层使用了拉链法；
 - [ ] 保证线程安全的方式：
    - [ ] jdk.17:对bucketTable使用了分段加锁的方法，保证并发的线程安全性；
    - [ ] jdk1.8:摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作；
    - [ ] synchronized 和 CAS的方式，只锁定当前链表或者红黑树的首节点，相当于对bucketTable数组中的每一个对象都加锁；
 - [ ] 与HashTable的对比：HashTable只使用了一把锁，效率非常低下；

##### Set

- [ ] HashSet：
  - [ ]  Set 接口的主要实现类 ，HashSet 的底层是 HashMap，线程不安全的，可以存储 null 值；
  - [ ] 直接通过HashMap实现，通过内部的HashMap成员HashMap<E,Object> map 来访问HashMap的方法；
  - [ ] HashSet实现Map时，只有key，没有value，value是HashSet类的静态私有成员private static final Object PRESENT = new Object();
- [ ] LinkedHashSet：HashSet 的子类，能够按照添加的顺序遍历；
- [ ] TreeSet ：底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。

##### Iterator
- [ ] forEach循环：增强型for循环

```java
List<String> list = new ArrayList<String>();
for(String e : list){
	// TODO
}
```
本质是使用了迭代器Iterator对Collection中的对象进行遍历。

- [ ]  fail-fast机制（快速失败）：一种集合的错误检测机制，当使用迭代器遍历集合时，若集合被修改，则会触发fail-fast机制，抛出ConcurrentModificationException异常；另外，在单线程下，如果在遍历过程中对集合对象的内容进行了修改的话也会触发 fail-fast 机制。
- [ ]  fail-safe机制（安全失败）：采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。所以，在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常。

#### JVM

- [ ] 对象的引用存放的栈内存中，对象的实例存放在堆内存中；

##### Java内存区域

- [ ] 线程私有的部分：
  - [ ] 1）程序计数器 Program Counter Register
  - [ ] 2）虚拟机栈 VM Stack
  - [ ] 3）本地方法栈 Native Method Stack
- [ ] 线程共享的部分：
  - [ ] 1）堆 Heap
  - [ ] 2）方法区 Method Area（jdk1.8之前）
  - [ ] 3）直接内存 Direct Memory（jdk1.8之后，元空间Metaspace位于直接内存）
- [ ] 各部分介绍
  - [ ] 1）程序计数器
    - [ ] 存储当前线程运行的字节码行号；
    - [ ] 主要作用：
    - [ ] 1）解释器通过改变程序计数器，依次读取指令，实现代码的流程控制；顺序执行、选择、循环、异常处理等；
    - [ ] 2）多线程情况下，线程切换之后，根据程序计数器来判断原先的程序执行到哪一行；
  - [ ] 2）虚拟机栈
    - [ ] 存放方法的参数以及局部变量和引用；
    - [ ] 虚拟机栈会产生两种Error：
      - [ ] 1）StackOverFlowError 当虚拟机栈不能动态扩展，那么当线程请求栈的深度超过最大限度，会抛出该错误；
      - [ ] 2）OutOfMemoryError 当虚拟机栈的内存大小允许动态扩展，那么当JVM的内存不足时，抛出该错误；
  - [ ] 3）本地方法栈
    - [ ] 为虚拟机使用到的Native方法服务；
    - [ ] 与虚拟机栈类似，虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为虚拟机执行Native方法服务；
    - [ ] HotSpot虚拟机中，虚拟机栈与本地方法栈合二为一；
    - [ ] 栈帧中保存局部变量表、操作数栈、动态链接、出口信息；
    - [ ] 也会出现StackOverFlowError和OutOfMemoryError；
  - [ ] 4）堆 
    - [ ] 存放对象实例，几乎所有的对象实例以及数组都在堆中分配；
    - [ ] 是虚拟机内存中的最大的部分，为所有线程共享；
    - [ ] 又称GC堆；垃圾回收使用了分代垃圾回收算法，因此Java堆还可以分为：
      - [ ] 新生代：Eden空间、From Survivor（S0）、To Survivor（S1）；
      - [ ] 老年代（tentired）
    - [ ] 进一步的堆划分，是为了更好地进行内存回收；
    - [ ] 大部分情况，新对象会进入Eden区，一次新生代垃圾回收后，如果对象存活，则会进入S0或者S1，并且对象年龄+1；当对象年龄增加到一定程度（默认15），则会被晋升到老年代；
  - [ ] 5）方法区
    - [ ] 存储已被虚拟机加载的类信息、常亮、静态变量、JIT编译后的代码；
    - [ ] 为所有线程共享；
    - [ ] 又叫Non-Heap（非堆），为了与Java堆区分出来；
    - [ ] 永久代 方法区也被称为永久代，是HotSpot独有的；
    - [ ] 常用参数：
      - [ ] -XX:PermSize=N // 方法区（永久代）初始大小
      - [ ] -XX:MaxPermSize=N // 方法区（永久代）最大大小，超过这个值将会抛出OutOfMemoryError错误
  - [ ] 6）元空间
    - [ ] JDK 1.8 使用了元空间代替方法区；
    - [ ] 元空间使用直接内存；
    - [ ] 为什么使用元空间代替方法区：
      - [ ] 方法区在运行时内存空间，其空间大小不可扩展；
      - [ ] 元空间使用直接内存，只受主机物理内存的限制；
  - [ ] 7）运行时常量池
    - [ ] JDK1.7及之后的版本，将运行时常量池从方法区移到堆中；
    - [ ] 用于存放编译时产生的各种字面量和符号引用；
    - [ ] 常量池包含内容：
      - [ ] 1）字面量
        - [ ] 1.1）文本字符串
        - [ ] 1.2）final限定的常亮
        - [ ] 1.3）基本数据类型缓存值
        - [ ] 1.4）其他
      - [ ] 2）符号引用
        - [ ] 2.1）类和结构的完全限定名
        - [ ] 2.2）字段名称和描述符
        - [ ] 2.3）方法名称和描述符
  - [ ] 8）直接内存
    - [ ] JDK1.4中引入NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓存区（Buffer）的I/O方式；
    - [ ] 使用Native函数库直接分配堆外内存；
    - [ ] 使用一个存储在Java堆中的DirectByteBuffer对象最为堆外内存的引用进行操作；

##### Java对象创建过程

- [ ] 大致流程：
  - [ ] 1）类加载检查
    - [ ] 遇到new指令时，首先在常量池中寻找类的符号引用，并检查这个符号引用对应的类是否被加载、解析和初始化；如果没有，则必须先执行相应的类加载过程；
  - [ ] 2）分配内存
    - [ ] 通过类加载检查之后，接下来为新生对象分配内存；
    - [ ] 分配方式有“指针碰撞”和“空闲列表”两种，具体由JVM决定；
    - [ ] 选择哪种分配方式，取决于Java堆内存是否规整；
    - [ ] Java堆内存是否规整，取决于GC收集器的算法是“标记-清楚”还是“标记-整理”（也称“标记-压缩”）；
    - [ ] 分配内存算法
      - [ ] 1）指针碰撞
        - [ ] 使用场合 堆内存规整情况下（没有内存碎片）
        - [ ] 原理 用过的内存放到一遍，没有用过的内存放到另一边，使用分界值指针标记，保留指针左侧内存，忽略指针右侧内存；
        - [ ] GC收集器：Serial、ParNew
      - [ ] 2）空闲列表
        - [ ] 使用场合 堆内存不规整的情况下
        - [ ] 原理 虚拟机维护一个列表，该列表记录那些内存块是可用的，分配时找一块足够大的内存块来划分给对象实例，并更新列表记录；
        - [ ] GC收集器：CMS
    - [ ] 内存分配的并发问题
      - [ ] 多线程进行对象创建时，要保证线程安全；
      - [ ] JVM使用两种方式保证线程安全：
        - [ ] 1）CAS+失败重试
        - [ ] 2）TLAB 每个线程都预先在Eden区分配一段内存空间，JVM在分配内存时，现在TLAB分配，如果TLAB空间用尽，则再使用CAS进行内存分配；
  - [ ] 3）初始化零值
    - [ ] 分配内存之后，将内存空间的初始化为零值（不包括对象头）；
    - [ ] 该操作保证对象可以不赋初值直接使用；
  - [ ] 4）设置对象头
    - [ ] 初始化零值后，JVM对对象做一些必要的设置；
    - [ ] 比如这个对象是哪个类的实例；如何才能找到类的元数据信息；对象的哈希码；对象的GC分代年龄；
  - [ ] 5）执行init方法
    - [ ] 上面的工作完成之后，执行<init>方法（构造方法），把对象按照程序员的意愿进行初始化；

##### 两种对象的访问定位方式

- [ ] 使用句柄 和 直接指针

#### Java多线程

##### 线程和进程

- [ ] 定义：
  - [ ] 进程是系统运行程序的基本单位，进程是动态的；
  - [ ] 线程类似与进程，是更小的程序执行单位；一个进程在执行过程中可以产生多个线程；多个县城共享进程的堆和方法区资源；线程的产生、切换的负担要比进程低，因此也被称为轻量级进程；
- [ ] 区别和优缺点
  - [ ] 

#### Java注解
#### Java内部类、匿名内部类
- [ ] jvm
- [ ] Sql索引
- [ ] Spring、Spring boot
- [ ] Spring AOP：如果目标对象继承了接口，那么默认使用JDK动态代理，否则采用CGLIB动态代理；
- [ ] 设计模式
### 计算机网络
#### 五层协议体系结构
- [ ] 自顶向下：1）应用层；2）运输层；3）网络层；4）数据链路层；4）物理层
- [ ] 1）应用层（application layer）
  - [ ] 应用层的任务是通过应用进程之间的交互来完成特定的网络应用；
  - [ ] 应用层常见协议：
    - [ ] 使用TCP
      - [ ] 电子邮件系统
      - [ ] http 超文本传输协议 默认端口80
      - [ ] FTP 文件传输协议 端口20/21
    - [ ] 使用UDP
      - [ ] 域名系统DNS 端口53
      - [ ] DHCP 动态主机配置协议 给局域网用户分配IP地址
- [ ] 2）运输层（transport layer）
  - [ ] 保证端到端的传输：运输层为两台主机进程之间的通信提供通用的数据传输服务
    - [ ] 运输层主要的协议：
      - [ ] 1）TCP 传输控制协议，提供面向连接的可靠传输服务。
      - [ ] 2） UDP 用户数据协议，提供无连接的高效传输服务，不保证数据传输的可靠性。
- [ ] 3）网络层
  - [ ] 功能
    - [ ] 1）将运输层产生的报文（TPC报文段，UDP用户数据报），分为IP数据报，分组分包发送；
    - [ ] 2）子网控制，网间路由，选择合适的数据传送方向；
  - [ ] 计算机网络中的两台计算机之间的通信，可能经过多个数据链路，可能会通过多个通信子网层；网络层的任务是，选择合适的网间路由和交换结点，确保数据及时传送；发送数据时，网络层将运输层产生的报文段或者用户数据报，封装成分组和包进行传送；由于TCP\IP协议中，网络层使用了IP协议，因此分组也叫IP数据报；
- [ ] 4）数据链路层（data link layer)
  - [ ] 物理寻址：负责相邻接点之间的数据传输；
  - [ ] 数据链路层将网络层交下来的IP数据报，组装成帧，每一帧包含数据信息、必要的控制信息（同步信息、地址信息、差错控制）；
  - [ ] 数据链路层还会进行差错控制，将出现差错的帧丢弃，或者对其进行纠错；
- [ ] 5）物理层

#### TCP/UDP

- [ ]  TCP 三次握手 四次挥手
  - [ ] 三次握手
    - [ ] 目的：建立可靠的连接
    - [ ] 连接标准，怎样算可靠：发送方和接收方，都要确认自己和对方的发送正常、接受正常；
    - [ ] 过程：
      - [ ] 1）发送方发送SYN（synchronous请求同步）
      - [ ] 2）接收方收到，接收方确认自己接受正常，发送方发送正常；接收方向发送方发送SYN/ACK（acknowledgement 确认）；
      - [ ] 3）发送方确认自己发送、接受正常，接收方发送、接受正常；发送方向接收方发送ACK；
      - [ ] 4）接收方确认发送方接受正常，建立连接；
  - [ ] 四次挥手
    - [ ] 目的：确认连接双方都结束连接
    - [ ] 1）主动结束方，向被动结束方发送FIN（finish结束）；
    - [ ] 2）被动方收到，向主动方发送ACK；主动方等待被动方发送FIN；
    - [ ] 3）被动方发送FIN；
    - [ ] 4）主动方收到，向被动方发送ACK，成功释放链接；
- [ ] TCP如何保证可靠传输
  - [ ] TCP将数据分段 数据块大小较为合适
  - [ ] TCP将每一个包标号 接收方对收到的数据包进行排序 把有序数据传送给应用层
  - [ ] 校验和 丢弃校验出错的数据
  - [ ] 丢弃重复的数据
  - [ ] 流量控制：为了防止接收端的缓冲空间不足，当接收端来不及处理数据时，提示发送方降低发送的速率，防止包丢失；
  - [ ] 拥塞控制：当网络拥塞时，减少数据的发送；
  - [ ] ARQ协议：为了实现可靠的传输，每发完一个分组就停止发送，等待对方确认，收到确认后再发送下一个分组；
  - [ ] 超时重传：当TCP发送一个分组后，在规定时间内没有收到对方的确认信息，则重发这个报文段；
- [ ] ARQ协议 自动重传请求（Automatic Repeat-reQuest）
  - [ ] OSI模型中的数据链路层、传输层的错误纠正协议之一；它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输；
  - [ ] 停止等待ARQ协议
    - [ ] 为了实现可靠传输，当TCP发送一个分组后，在规定时间内没有收到对方的确认信息，则重发这个报文段；
    - [ ] 若接收方收到重复分组，则丢弃，但是仍然要发送ACK确认；
    - [ ] 优点：简单
    - [ ] 缺点：信道利用率低 等待时间长
  - [ ] 连续ARQ协议
    - [ ] 发送方维持一个发送窗口，但凡位于发送窗口内的分组，可以连续发送出去，而不需要等待对方确认；接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表示到这个分组为止的所有分组都已经正确收到；
    - [ ] 接收方如果接收到了不连续的分组，比如1,2,3,5,分组4丢失了，那么接收方将会发送一个分组3的ACK确认信息；
    - [ ] 优点：信道利用率高，容易实现，即使确认丢失，也不必重传；
    - [ ] 缺点：不能反映接收方已经正确受到的所有分组信息；比如分组4丢失了，而分组5,6均未丢失，发送方仍然会将4,5,6重传；
- [ ] 滑动窗口和流量控制
  - [ ] 流量控制：接收方为了防止处理超出缓冲空间的数据，主动要求接收方调整发送流量；
  - [ ] TCP使用滑动窗口进行流量控制，流量控制是为了控制发送方速率，保证接收方来得及接受；接收方发送的ACK确认报文中的窗口字段信息，可以用来控制发送方的窗口大小，从而影响发送方的发送速率；将窗口字段设置为0，则发送方不能发送数据；
- [ ] 拥塞控制
  - [ ] 拥塞控制：发送方为了防止网络负荷过大，主动调整自身发送流量；
  - [ ] 为了进行拥塞控制，TCP发送方维持一个拥塞窗口；发送方根据拥塞窗口和接收方的流量控制窗口，取较小值来决定发送数据量；
  - [ ] 拥塞控制的四种算法：
    - [ ] 慢开始：由小到大地提高拥塞窗口的大小，以试探当前网络的用色情况；cwnd的初始值为1，试探1次（传播1次），将拥塞窗口的长度加倍；慢开始算法的思想是，一开始发送数据时，不清楚当前网络的情况；
    - [ ] 拥塞避免：每完成1次传播，将cwnd的长度+1；算法思想是，让拥塞窗口缓慢增大；
    - [ ] 快重传与快恢复（FRR, fast retransmit and recovery）：在不使用FRR的情况下，如过数据包丢失，则传输将会暂停；有了FRR的情况下，当有包丢失时不暂停，接收方只有当收到3个重复确认时，才会假定确认指出的数据段丢失，并对其进行重传；FRR在有单独的数据包丢失时，效率是最高的；当多个数据包在短时间内丢失时，则不能很有效地工作；
- [ ] 在浏览器中输入URL->显示主页的过程
  - [ ] 1）查找域名的IP地址：
  - [ ] 2）向web服务器发送http请求
  - [ ] 3）服务器请求处理
  - [ ] 4）服务器发回HTML响应
  - [ ] 5）浏览器显示HTML
  - [ ] 解析:
    - [ ] 1使用了DNS协议
    - [ ] 2-5是客户端（浏览器）与服务端（web服务器）之间的进程交互，使用了TCP/IP网络模型中的主要协议，包括HTTP（访问HTML网页）、TCP（传输层建立连接）、IP（网络层）、OPSF（IP数据包在路由器之间的传输协议）、ARP（网络层、地址解析协议，将ip地址转换为mac地址）
- [ ] http状态码
  - [ ] 1xx:信息性状态码 接收到的请求正在处理
  - [ ] 2xx:成功状态嘛 请求正常处理完毕
  - [ ] 3xx:重定向状态码 需要进行附加额外操作以完成请求
  - [ ] 4xx:客户端错误 服务器无法处理请求
  - [ ] 5xx:服务器错误 服务器处理请求出错
- [ ] http长连接 短连接
  - [ ] 短连接
    - [ ] 定义：指客户端与服务器的每一次HTTP操作，都会建立TCP连接；
    - [ ] HTTP/1.0中 默认使用短连接
  - [ ] 长连接
    - [ ] 定义：指客户端与服务器建立TCP连接之后，该连接会维持一段时间；该连接不会永久维持，在服务器端可以设置保持时间；
    - [ ] HTTP/1.1起 默认使用长连接
- [ ] HTTP如何保存用户状态
  - [ ] html是无状态的协议
  - [ ] 使用Session和Cookie来跟踪浏览器用户身份；Session用于服务器端，Cookie用于浏览器端；
  - [ ] 服务器端可以使用Session来保存用户状态，但是无法区分每一次请求是来自于哪一个用户；
  - [ ] 客户端使用Cookie来保存用户信息，通常在Cookie中附加一个Session ID来进行跟踪；
  - [ ] 由于Session在服务器端，它的安全性比Cookie更高；如果要在Cookie中存储敏感信息，则要进行加密；
- [ ] HTTP 1.0与1.1的区别
  - [ ] 1)长连接与短连接
  - [ ] // TODO
- [ ] HTTP与HTTPS的区别
  - [ ] 1）端口：HTTP默认使用80端口，url以"http://"开始’；HTTP默认使用443端口，url以"https://"开始’；
  - [ ] 2）安全性和资源消耗：
    - [ ] http协议以明文传输数据，安全性低；https对数据内容进行加密，安全性高，但是更占用服务器资源；
### 操作系统

#### 操作系统基础

- [ ] 用户态与内核态
  - [ ] 1）用户态（user mode） 用户态运行的进程 仅可以直接读取用户程序的数据
  - [ ] 2）内核态（kernel mode） 内核态运行的进程 可以访问计算机的任何资源 不受限制
- [ ] 系统调用
  - [ ] 一般的应用程序是运行在用户态的，如果需要调用操作系统提供的内核态级别的子功能，那就需要使用系统调用；
  - [ ] 凡是与操作系统级别的资源有关的操作（设备管理、文件管理、进程控制、进程通信、内存管理等），都需要通过系统调用的方式向操作系统提出服务请求，并由操作系统代为完成；

#### 进程管理

- [ ] 进程与线程
  - [ ] 线程是将进程划分得更小的运行单位，一个进程可以产生多个线程；多个进程之间基本是独立的，而同一个进程产生的线程，可以共享部分资源；进程开销大，线程开销小；
- [ ] 进程有哪几种状态（5种）
  - [ ] 1）创建状态（new） 进程正在被创建 尚未就绪；
  - [ ] 2）就绪状态（ready） 进程已处于准备运行的状态 获得了除了CPU之外的所需资源
  - [ ] 3）运行状态（running） 进程正在处理器上运行
  - [ ] 4）阻塞状态（waitting） 又称等待状态 指进程正在等待某一事件而暂停运行 如等待IO操作完成
  - [ ] 5）结束状态（terminated） 进程从操作系统中消失
- [ ] 进程通信方式
  - [ ] 1）管道/匿名管道（pipes） 具有亲缘关系的父子进程或者兄弟进程之间的通信
    - [ ] 解析：linux的管道操作“|” 即父进程执行完之后 将执行结果作为子进程的输入 执行子进程
    - [ ] 瀑布式软件模型 效率低下
  - [ ] 2）有名管道（names pipes） 有名管道以磁盘文件的方式存在 可以实现本机任意两个进程的通信 严格遵循先进先出的原则（FIFO）
    - [ ] 解析：同匿名管道
  - [ ] 3）信号（Signal） 用于通知接受进程某个事件已经发生
  - [ ] 4）消息队列（Message Queuing） 消息的链表 跟随操作系统内核 存储于内存 有足够权限的进程可以向其中读取、写入消息 做到进程之间的异步通讯
    - [ ] 解析：可分为单机消息队列 跨主机消息队列（MQ中间件）
  - [ ] 5）信号量（Semaphores） 用于多进程对共享数据的访问 用于进程间的同步
  - [ ] 6）共享内存（Shared memory） 使得多个进程可以访问同一块内存空间 最有效的进程间通信方式
    - [ ] 解析：多个进程的逻辑地址 指向了相同的物理内存地址
    - [ ] 多进程对共享内存区域的访问 应该是互斥的
    - [ ] 是最简单的进程通信技术
  - [ ] 7）套接字（Sockets） 主要用于客户端和服务器之间通过网络进行通信
- [ ] 线程间的同步方式
  - [ ] 线程同步是两个或者多个共享关键资源的线程的并发执行；一般有三种线程同步方式：
    - [ ] 1）互斥量（Mutex） 采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限；java的synchronized关键字和各种lock都是这种机制；
    - [ ] 2）信号量（Semphares） 允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问该资源的最大线程数量；
    - [ ] 3）事件（Event）
- [ ] 锁机制
  - [ ] 悲观锁与乐观锁
    - [ ] CAS
      - [ ] Compare-and-Swap，即“比较并替换”
      - [ ] CAS操作是原子性的
      - [ ] 操作流程：1）读取A值，在将A更新为B之前，检查原值是否仍为A；2）如果是，将A更新为B；如果不是，则什么都不做；
      - [ ] 乐观锁就是循环重试的CAS
    - [ ] 1） 悲观锁 
      - [ ] 阻塞事务，适用于写讲多的场景；
      - [ ] 每次拿数据的时候都上锁；认为别人会对其进行修改；
    - [ ] 2）乐观锁 
      - [ ] 回滚重试，适用于读较多的场景；
      - [ ] 不上锁，只有当写入数据时，才检查读取期间是否有人对其进行修改；若修改过，则再次读取，重新尝试更新；认为别人都不会对数据进行修改；
  - [ ] 偏向锁 → 轻量级锁 → 重量级锁
    - [ ] 偏向锁：当某个synchronized的资源，只被一个线程占用，那么它使用的是偏向锁；
    - [ ] 轻量级锁、自旋锁：当超过1个线程竞争某个synchronized的资源，则会升级成轻量级锁；没有抢到锁的线程会不停地执行while(true)循环，进入忙等（busy-waiting）状态，即为自旋锁；
    - [ ] 重量级锁：当某个自旋锁自选次数过高（默认10次），那么表明锁竞争情况严重，将会升级为重量级锁；当后续线程尝试获取锁时，发现对方是重量级锁，则会将线程自己挂起，而不是忙等，等待将来被唤醒；
  - [ ] 可重入锁（递归锁）
    - [ ] 可重入锁：允许同一个线程多次获取同一把锁；
    - [ ] 场景：对于递归函数里的加锁操作，每一次递归调用都需要加锁；
    - [ ] Java里只要以Reentrant开头命名的锁都是可重入锁，而且JDK提供的所有现成的Lock实现类，包括synchronized关键字锁都是可重入的；
  - [ ] 公平锁与非公平锁
    - [ ] 公平锁：满足“先申请、先得到”原则的锁；
    - [ ] 非公平锁：不满足公平锁要求的锁；
    - [ ] 一般非公平锁的吞吐量更大，如果没有特殊要求，优先使用非公平锁；
    - [ ] synchronized使用的是一种非公平锁，但是并没有任何办法使其变成公平锁；
  - [ ] 可中断锁
    - [ ] 可中断锁：长时间等待资源的情况下，可以将线程自身中断，或者用别的线程将其中断，则为可中断锁；
    - [ ] Java本身不提供线程中断机制，而是对线程发出“应该被中断”的消息，线程自身决定了收到中断消息之后该如何处理；
    - [ ] synchronized就是不可中断锁，而Lock的实现类都是可中断锁；
- [ ] 进程的调度算法
  - [ ] 1）先到先服务（FCFS）
  - [ ] 2）短作业优先（SJF）
  - [ ] 3）时间便轮转（RR round robin）
  - [ ] 4）多级反馈队列调度
  - [ ] 5）优先级调度

#### 内存管理

- [ ] 内存管理的功能
  - [ ] 1）负责内存的分配（malloc）和回收（free）
  - [ ] 2）将逻辑地址与实际物理地址进行映射转换
- [ ] 常见的内存管理机制
  - [ ] 连续分配管理方式
    - [ ] 1）块式管理 将内存分为几个大小固定的块，每个块中只允许一个进程运行；碎片多；
  - [ ] 非连续分配管理方式
    - [ ] 1）页式管理 将内存分为多个大小相等且固定的页，页较小，划分力度大，提高了内存的利用率，减少碎片；通过页表对逻辑地址和物理地址进行映射；
    - [ ] 2）段式管理 将内存分为比页更小的段空间，并且每个段都是有实际意义的，定义了逻辑信息，比如主程序段MAIN、子程序段X、数据段D以及栈段S等；
    - [ ] 3）段页式管理 结合了段氏管理和页式管理，现将主存分段，然后将每段分页；
- [ ] 段式管理与页式管理的异同
  - [ ] 相同点：
    - [ ] 1）都采用了内存划分的方法，提高了内存利用率，减少碎片；
    - [ ] 2）段和页的存储是离散的，但是段内与页内的代码是连续的；
  - [ ] 不同点：
    - [ ] 1）页的大小是固定的；段的大小不固定，取决于当前运行的程序；
    - [ ] 2）页不具备逻辑信息，而段式有逻辑信息的，比如代码段、数据段；
- [ ] 快表和多级页表
  - [ ] 分页内存管理中，很重要的两点是：
    - [ ] 1）效率 虚拟地址和物理地址的转换要快；
    - [ ] 2）空间 如果虚拟地址空间很大，页表也会很大；
  - [ ] 页表：进行虚拟空间与物理空间之间的映射转换；
  - [ ] 快表：页表的Cache；
  - [ ] 多级页表：为页表建索引；为了防止页表过大，无法全部加载入内存，将页表进行划分，并使用索引来进行划分页表的映射；
- [ ] 逻辑地址与物理地址
- [ ] CPU寻址 为什么要使用虚拟地址空间
  - [ ] CPU寻址：CPU将程序的逻辑地址，映射为物理地址；
  - [ ] 为什么使用虚拟地址：
    - [ ] 1）如果直接使用虚拟地址，一个进程可以访问别的进程的内存空间；
    - [ ] 2）如上，操作系统容易崩溃；
    - [ ] 3）如上，多进程之间可能存在干扰；
  - [ ] 总结：直接把物理地址暴露出来的话，会带来严重的危害，影响操作系统，以及对多个进程的同时运行造成困难；
  - [ ] 虚拟地址的优势：
    - [ ] 1）可以使用相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区；
    - [ ] 2）可以使用虚拟地址来访问大于可用物理内存的内存缓冲器（虚拟内存）；
    - [ ] 3）不同进程使用虚拟地址进行相互隔离；进程的内存空间不会被别的进程修改；

#### 虚拟内存

- [ ] 虚拟内存的定义
  - [ ] 0）将内存作为外存的缓存，在增大逻辑存储空间的同时，提高程序的运行效率；
  - [ ] 1）当主存不足时，使用部分的外存来替代主存，实现逻辑上的存储空间扩展；
  - [ ] 2）对于进程来说，逻辑空间是连续的，进程不需要知道自己是运行在主存之上，还是虚拟内存之上；
- [ ] 局部性原理：
  - [ ] 1）时间局部性 某条指令被执行，那么它不久后大概率会被再次执行；
  - [ ] 2）空间局部性 某个存储单元被访问，那么接下来它附近的存储单元也大概率会被访问；
- [ ] 虚拟存储器
  - [ ] 虚拟存储器=内存+虚拟内存
  - [ ] 虚拟存储器可以为用户提供一个大于物理内存的存储空间；
- [ ] 虚拟内存的技术实现
  - [ ] // TODO
- [ ] 页面置换算法
  - [ ] 地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断；
  - [ ] 当发生缺页中断时，操作系统需要选择一个页面，移出主存，从而将所需的页面调入；
  - [ ] 页面置换算法：
    - [ ] 1）OPT（最佳页面置换算法）选择在将来最长时间内不会被访问的页面；由于无法预知那个页面是最长时间内无法被访问的，因此该算法无法实现；
    - [ ] 2）FIFO（先进先出页面置换算法）总是淘汰最先进入主存的页面；
    - [ ] 3）LRU（Least Currently Used 最近最久未使用）选择最长时间未被使用的页面进行淘汰；
    - [ ] 4）LFU（Least Frequently Used 最少使用）选择被调用次数最少的页面进行淘汰；

### 数据库

#### MySQL

- [ ] InnoDB MySQL使用的事务性数据库引擎

##### 索引

- [ ] 作用：缩短数据库的搜索时间
- [ ] MySQL索引的主要数据结构
  - [ ] BTree索引 大部分场景使用B树索引
  - [ ] Hash索引 对单条记录进行查询时 查询最快

##### 事务

- [ ] 定义：一组原子性的操作，要么都执行，要么都不执行；
- [ ] 在MySQL中执行查询、修改语句，默认会包装成事务，并且直接COMMIT；
- [ ] 显式事务：使用BEGIN开始一个事务；使用ROLLBACK回滚事务；使用COMMIT确认事务，结束一段事务的编写；
- [ ] 四大特性（ACID）
  - [ ] 1）原子性（Automicity） 事务的操作不可分割，要么都执行，要么都不执行；
  - [ ] 2）一致性（Consistency） 执行事务前后，数据保持一致；多个事务对同一数据的读取结果是相同的；
  - [ ] 3）隔离性（Isolation)  并发访问数据库时，一个用户的事务不会被其他事务所干扰；并发事务之间的数据库是独立的；
  - [ ] 4）持久性（Durability） 一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障，对数据也没有影响；
- [ ] 并发事务带来的问题：
  - [ ] 1）脏读（Dirty read） 当数据被修改后，但是没有提交之前，被另一个事务读了；
  - [ ] 2）丢失修改（Lost to modify） 一个事务修改了数据之后，但是没有提交之前，被另一个事务修改并覆盖了；
  - [ ] 3）不可重复读（Unrepeatable read） 一个事务多次读取相同数据时，前后数据值不相同的情况；
  - [ ] 4）幻读（Phantom read） 一个事务多次读取相同表中的内容时，表中有新增行或者删除行的情况；
- [ ] 事务隔离级别
  - [ ] InnoDB默认隔离级别：可重复度（REPEATABLE-READ） 
  - [ ] 1）读取未提交（READ-UNCOMMITTED） 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读、不可重复读；
  - [ ] 2）读取已提交（READ-COMMITTED） 允许读取并发事务已提交的数据，可以阻止脏读，但仍可能发生幻读或者不可重复读；
  - [ ] 3）可重复度（REPEATABLE-READ） 对同一字段的多次读取结果都是一致的，除非数据是被事务自己修改的；可以阻止脏读和不可重复读，但是不能阻止幻读；
  - [ ] 4）可串行化（SERIALIZABLE） 最高的隔离级别，所有事务串行执行；该级别可以防止脏读、不可重复读和幻读；
  - [ ] 在分布式事务的情况下，InnoDB一般使用可串行化（SERIALIZABLE）隔离级别；

##### 大表优化

- [ ] 常见的优化措施：
  - [ ] 1）限定数据的范围 读取数据值务必禁止不带任何限制数据范围条件的查询语句；
  - [ ] 2）读写分离 将数据库拆分，主库负责写，从库负责读；
  - [ ] 3）垂直分区 根据数据库中数据表的相关性，按列将大表拆分为小表；
    - [ ] 优点：可以使得列数据变少，减少查询时的I/O次数，简化表的结构；
    - [ ] 缺点：主键冗余，需要在应用层进行额外的join操作；
  - [ ] 4）水平分区 保持数据表结构不变，使用某种策略将存储数据分片，每一片数据分散到不同的表或者库中；
    - [ ] 水平拆分最好分库
    - [ ] 数据库分片会带来很对问题，数据拆分会提高逻辑、部署、运维的复杂度；

- [ ] 池化设计思想 数据库连接池
  - [ ] 数据库连接的本质，是socket连接，基于TCP协议，是有连接的；
  - [ ] 池化思想类似于缓存，将新的数据库连接保存在连接池中，当再次使用时从连接池中获取，而不需要再次建立新的连接；
  - [ ] 连接池减少了用户等待建立与数据库之间的连接的时间；
- [ ] 分库分表之后 如何选取id主键
  - [ ] 1）UUID 不适合作为主键，因为太长了，影响性能；
  - [ ] 2）数据库自增id 两台数据库设置不同的自增步长或者初始值，生成不重复的ID；缺点是每个数据库都需要独立部署，成本高，并且存在性能瓶颈；
  - [ ] 3）利用redis生成id // TODO
  - [ ] 4）雪花算法（snowflake） 源自twitter，使用64位long数据作为id，记录符号（1位）、时间戳（41位）、机器id（10位）、序列号（12位）信息；
  - [ ] 5）号段模式 从数据库向主数据库申请号段（比如(0,1000])，当号段内id使用完后，再次向主数据库申请新的号段；主数据库相当于索引；

##### SQL语句在MySQL中如何执行

- [ ] MySQL基本框架
  - [ ] 1）客户端 
  - [ ] 2）Server端
    - [ ] 2.1）连接器 身份认证和权限相关；
    - [ ] 2.2）查询缓存 （8.0版本后移除）执行查询语句时，先查询缓存；
    - [ ] 2.3）分析器 词法分析 语法分析
    - [ ] 2.4）优化器 MySQL会按照它认为的最优方案进行查询
    - [ ] 2.5）执行器 执行查询语句，从存储引擎返回数据；
    - [ ] 2.6）日志Binlog
  - [ ] 3）存储引擎 负责数据的存储和读取，是可替换的插件式的；其中InnoDB引擎自带redolog日志模块；
- [ ] 查询过程 // TODO
- [ ] 更新过程 // TODO

##### MySQL优化

- [ ] 一条SQL语句查询过慢 原因是什么
  - [ ] 分两种情况：偶尔很慢、一直很慢
  - [ ] 1）偶尔很慢
    - [ ] 1.1）数据库在刷新脏页（flush）
      - [ ] 脏页：内存中的数据和磁盘中的数据不匹配的情况；
      - [ ] InnoDB在写数据时，会将数据先暂存到内存中，存在redo log日志里；
      - [ ] 什么情况下会刷新脏页：
        - [ ] redo log写满了 要将数据同步到磁盘；
        - [ ] 内不能不够用，脏页被选中淘汰，淘汰之前要先将数据同步到磁盘；
    - [ ] 1.2）拿不到锁
      - [ ] 所需的数据的表级锁或者行级锁被占用；
  - [ ] 2）一直很慢
    - [ ] 2.1）字段没有使用索引
    - [ ] 2.2）字段有索引，但是查询时没有用到索引；如果查询时不是直接使用字段，而是字段的表达式，则不会使用索引；
    - [ ] 2.3）表有索引，但是数据库选错了索引；

##### MySQL调优

- [ ] // TODO

#### Redis

##### 基础

- [ ] Redis是一个存储在内存中的key-value缓存数据库，读写速度非常快，广泛应用于缓存方向；redis也经常用来做分布式锁；redis支持事务、持久化、LUA脚本、LRU驱动事件、多种集群方案；
- [ ] 高性能与高并发
  - [ ] 高性能：使用缓存，只有第一次从磁盘中读取速度较慢，后续如果命中缓存，从缓存中读取速度较快；
  - [ ] 高并发：可以考虑将数据库中的部分数据转移到内存，这样可以提高能够承受的请求数；
- [ ] 使用redis不需要用户验证，但是可以设置密码；
- [ ] 使用“GET”、“SET”关键字进行string类型变量的存取，“SET str1 abc”表示将字符串“abc”赋给变量str1，“GET str1”将返回变量str1的值“abc”；
- [ ] 使用“HMGET”、“HMSET”、“HGET”、“HSET”关键字进行hash类型变量的存取，“SET hash1 field1 a field2 b”表示hash对象赋给变量hash1，这个hash对象有两个字段，字段field1的值为“a”，字段field2的值为“b”；
- [ ] redis支持发布订阅功能
  - [ ] SUBSCRIBE channel [channel ...]
    订阅给定的一个或多个频道的信息。
  - [ ] PUBLISH channel message
    将信息发送到指定的频道。
- [ ] redis事务
  - [ ] 使用MULTI关键字标记事务开始，随后所有命令都会进入事务队列，返回QUEUED；
  - [ ] 使用EXEC关键字表示事务编写结束，开始执行；队列中的命令按顺序执行；
  - [ ] 事务中任意命令执行失败，其他命令仍然会执行；
  - [ ] 在事务执行的过程中，其他客户端提交的命令请求不会插入到事务执行命令序列中；
  - [ ] 单个redis命令是原子性的，但是redis事务不是原子性的；
  - [ ] redis事务没有失败回滚；
- [ ] redis支持LUA脚本
- [ ] redis持久化
  - [ ] 数据将会保存在dump.rdb文件中
  - [ ] 数据恢复，只需要将备份的dump.rdb文件移动到redis安装目录，并重新启动服务即可；
- [ ] redis的数据类型：
  - [ ] 1）string 字符串，二进制安全，可以用于存储图像或者序列化对象，最大能存储512M；
  - [ ] 2）hash 字典；
  - [ ] 3）list
  - [ ] 4）set
  - [ ] 5）sorted set
- [ ] redis命令
  - [ ] 1）DEL key 删除对象
  - [ ] 2）DUMP key 序列化对象
  - [ ] 3）EXISTS key 判断对象是否存在，存在则返回1，不存在则返回0；
  - [ ] 4）EXPIRE key seconds 为对象key设置过期时间seconds（秒），超时则会DEL key；
  - [ ] 5）EXPIREAT key timestamp 为对象key设置过期时间（时间戳） 
  - [ ] 6）PEXPIRE key milliseconds 为对象key设置过期时间（毫秒）

##### 缓存雪崩和缓存穿透

- [ ] 缓存雪崩
  - [ ] 定义：指缓存在同一时间内大面积失效，数据库将会积累过多的请求，造成短时间承受大量请求而雪崩；
  - [ ] 解决方案：
    - [ ] 事前：保证redis集群的高可用性，发现宕机需要尽快补上；选择合适的内存淘汰策略；
    - [ ] 事中：缓存+限流/降级 避免MySQL崩掉
    - [ ] 事后：利用redis持久化机制，利用磁盘中保存的数据，尽快恢复缓存；
- [ ] 缓存穿透
  - [ ] 定义：大量请求中的某个key在redis与MySQL都不存在，导致根本没有经过缓存，大量请求落到MySQL中；
  - [ ] 解决方法：
    - [ ] 1）对无效的key进行缓存，并设置过期时间，避免使用MySQL进行查询；并且对无效的key设置过期时间，防止redis雪崩；
    - [ ] 2）布隆过滤器，介于服务端与redis之间，实现1）中的效果；使用hash表，每个key占1位，不处理hash碰撞，因此结果的准确性不为100%；
- [ ] 如何解决redis的并发竞争key问题
  - [ ] 使用分布式锁（zookeeper和redis都可以实现），即多台服务器对相同资源进行请求时，需要加锁；
  - [ ] redis的分布式锁实现：
    - [ ] 1）SETNX key value命令 如果不存在key，则创建key，赋值value(不重要，可以存放锁的获取时间)，返回1；如果已存在key，则返回0；这个key值就可以当做分布式锁；
    - [ ] 2）加锁、释放锁需要服务器端进行操作，如果redis宕机，可能造成锁未被释放，但是持有锁的进程不能释放锁而中断；对此，要对锁设置有效时间EXPIRE；
    - [ ] 3）GETSET key value命令，如果某个锁被占用的时间过长，其他服务器可以使用GETSET命令抢占锁，并根据value值（锁被抢占的时间是否过期）判断是否成功拿到锁；

##### 保证缓存与数据库的一致性

- [ ] 1）将缓存与数据库的读写串行化
  - [ ] 一致性最高的方法
  - [ ] 注意
    - [ ] 1）仅适用于对一致性有高要求的场景；
    - [ ] 2）会严重降低系统的吞吐量，需要更多的机器来保证性能；
- [ ] 2）先更新数据库 再删除缓存
  - [ ] 最简单的方法
- [ ] 3）将“读数据-更新缓存”的请求写入一个队列
  - [ ] 较为复杂的方法

### Java常用框架

#### Spring

##### IOC&AOP

- [ ] IOC Inverse of Control 控制反转
  - [ ] 定义 是一种编程思想，将原本在程序中需要手动创建的对象，交给Spring框架来创建；
  - [ ] IoC容器实际上是个Map（key，value），Map中存放的各种对象；
  - [ ] IoC可以理解成对象工厂
- [ ] AOP Aspect Oriented Programming 面向切面编程
  - [ ] 定义：将与业务无关，但是业务模块公用的逻辑或者责任（如事务处理、日志、权限控制等）封装起来，减少重读代码，降低系统耦合度，提高拓展性和可维护性；
  - [ ] 基于动态代理
  - [ ] AOP工具
    - [ ] 1）Spring AOP 运行时增强，基于代理；
    - [ ] 2）AspectJ是编译时增强，基于字节码操作；
    - [ ] 如果切面较多，使用AspectJ的性能更强；

##### // TODO

#### MyBatis // TODO

- [ ] 一种ORM框架（Object Relation Mapping），在JDBC的基础上进行封装；

#### Kafka // TODO

- [ ]  一种分布式流处理平台
- [ ] 关键功能：
  - [ ] 1）消息队列
  - [ ] 2）容错的持久方式存储记录消息流
  - [ ] 3）流式处理平台
- [ ] 应用场景
  - [ ] 1）消息队列
  - [ ] 2）数据处理

####  Netty // TODO

- [ ] 一种通讯框架，用于服务器之间的网络通信；

### 其他

#### 认证授权

- [ ] 定义：
  - [ ] 认证 (Authentication) 你是谁；验证用户的身份的凭据；
  - [ ] 授权 (Authorization) 你有权限干什么；管理用户对于系统的访问权限；

#### Cookie

- [ ] Cookie和Session都是用来跟踪用户身份的会话模式；
- [ ] Cookie存放在客户端，一般用来保存用户信息；Session存放于服务器；
- [ ] Cookie中包含的信息有：
  - [ ] 1）用户的登录信息；用户首选项、主题和其他设置信息；
  - [ ] 2）保存session或者token，向后端发送请求时带上Cookie，这样后端就可以获取到session或者token，记录用户当前的状态；
- [ ] 没有Cookie 如何使用Session
  - [ ] 将Session ID放到url的请求中；
  - [ ] 但是用户体验和安全性都会降低；
- [ ] Cookie与Token的区别
  - [ ] Token在Cookie的基础之上，增加了签名（加密算法），安全性更强；

### 中间件

#### 消息队列

###### RocketMQ

- [ ] 

###### Kafka



### 数据结构

- [ ] 平衡二叉树
  - [ ] AVL和红黑树的区别
    - [ ] AVL数是严格的平衡二叉树，每个节点的左子树与右子树的高度差小于等于1；而红黑树是弱平衡二叉树，确保没有一条路径比其他路径长出两倍；相同节点数量的情况下，AVL树的深度比红黑树要小；
    - [ ] 红黑树的平均高度是log(n)，但是最坏情况下的高度不超过2log(n)；
    - [ ] AVL的旋转非常耗时，不适合插入与删除非常多的情况；红黑树的旋转次数少，适合插入与删除较多的情况；
    - [ ] AVL的高度比红黑树低，因此查询速度更快；

### 微服务

- [ ] 微服务解决的问题：单体地狱。如果将一个应用的多个模块，捆绑到同一个jar包（war包）中，会存在很多的问题；每个模块都在变更、迭代，导致生成的jar包非常臃肿；单个模块出现bug时，会影响到别的模块，bug难以定位；不同模块的负载是不同的，高负载的模块会对低负载模块造成影响，比如如果登录、支付功能捆绑在一起，若同一时间进行登录操作的用户过多，该模块将会占用更多的资源，导致支付模块可用的资源过少，影响性能；
- [ ] 微服务的作用：解耦合，将臃肿的单体应用程序，分解成一套较小的互联服务。
- [ ] 三大指标：高可用、高性能、高并发。
- [ ] 优点：1）解耦，将一个复杂问题转化为多个简单问题；2）独立开发，每个简单问题可以由不同的团队独立专注开发，并且不同的微服务可以使用不同的技术开发；3）独立部署，分布式部署。
- [ ] 缺点： 1）；2）微服务本身是分布式系统，整体复杂，模块间的通讯复杂，需要通过消息或者RPC进行进程间通信，模块之间的相互调用存在延迟，可能会引入新的问题；3）分区数据库，分布式事务的问题；4）测试微服务应用程序也很复杂；5）跨越多服务变更，多个服务之间具有依赖关系、启动顺序，变更时会遇到问题；6）微服务部署复杂；
- [ ] CAP定理
  - [ ] Consistency 一致性：更新操作成功并返回客户端之后，所有节点在同一时间的数据完全一致；
  - [ ] Availability 可用性：服务可用，在正常响应时间内可用；
  - [ ] Partition tolerance 分区容错性：分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。
  - [ ] CP系统，高一致系统，对数据准确性要求较高场景，金融系统通常是CP系统；
  - [ ] AP系统，高可用系统，需要保证99.999999%的时间都是可用的。

