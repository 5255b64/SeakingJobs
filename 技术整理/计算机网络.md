### 计算机网络

#### 五层协议体系结构

- [ ] 自顶向下：1）应用层；2）运输层；3）网络层；4）数据链路层；4）物理层
- [ ] 1）应用层（application layer）
  - [ ] 应用层的任务是通过应用进程之间的交互来完成特定的网络应用；
  - [ ] 应用层常见协议：
    - [ ] 使用TCP：
      - [ ] 电子邮件系统
      - [ ] http 超文本传输协议 默认端口80
      - [ ] FTP 文件传输协议 端口20/21
    - [ ] 使用UDP：
      - [ ] 域名系统DNS 端口53
      - [ ] DHCP 动态主机配置协议 给局域网用户分配IP地址
- [ ] 2）运输层（transport layer）
  - [ ] 保证端到端的传输：运输层为两台主机进程之间的通信提供通用的数据传输服务
    - [ ] 运输层主要的协议：
      - [ ] 1）TCP 传输控制协议，提供面向连接的可靠传输服务。
      - [ ] 2） UDP 用户数据协议，提供无连接的高效传输服务，不保证数据传输的可靠性。
- [ ] 3）网络层
  - [ ] 功能
    - [ ] 1）将运输层产生的报文（TPC报文段，UDP用户数据报），分为IP数据报，分组分包发送；
    - [ ] 2）子网控制，网间路由，选择合适的数据传送方向；
  - [ ] 计算机网络中的两台计算机之间的通信，可能经过多个数据链路，可能会通过多个通信子网层；网络层的任务是，选择合适的网间路由和交换结点，确保数据及时传送；发送数据时，网络层将运输层产生的报文段或者用户数据报，封装成分组和包进行传送；由于TCP\IP协议中，网络层使用了IP协议，因此分组也叫IP数据报；
- [ ] 4）数据链路层（data link layer)
  - [ ] 物理寻址：负责相邻接点之间的数据传输；
  - [ ] 数据链路层将网络层交下来的IP数据报，组装成帧，每一帧包含数据信息、必要的控制信息（同步信息、地址信息、差错控制）；
  - [ ] 数据链路层还会进行差错控制，将出现差错的帧丢弃，或者对其进行纠错；
- [ ] 5）物理层

#### TCP/UDP

- [ ] TCP 三次握手 四次挥手
  - [ ] 三次握手
    - [ ] 目的：建立可靠的连接
    - [ ] 连接标准，怎样算可靠：发送方和接收方，都要确认自己和对方的发送正常、接受正常；
    - [ ] 过程：
      - [ ] 1）发送方发送SYN（synchronous请求同步）
      - [ ] 2）接收方收到，接收方确认自己接受正常，发送方发送正常；接收方向发送方发送SYN/ACK（acknowledgement 确认）；
      - [ ] 3）发送方确认自己发送、接受正常，接收方发送、接受正常；发送方向接收方发送ACK；
      - [ ] 4）接收方确认发送方接受正常，建立连接；
    - [ ] 为什么不是两次握手
      - [ ] 1）如果是两次握手，接收方不能保证对方的接受和自己的发送的有效性；
      - [ ] 2）防止超时 // TODO
  - [ ] 四次挥手
    - [ ] 目的：确认连接双方都结束连接
    - [ ] 1）主动结束方，向被动结束方发送FIN（finish结束）；
    - [ ] 2）被动方收到，向主动方发送ACK；主动方等待被动方发送FIN；
    - [ ] 3）被动方发送FIN；
    - [ ] 4）主动方收到，向被动方发送ACK，成功释放链接；
- [ ] TCP如何保证可靠传输
  - [ ] TCP将数据分段 数据块大小较为合适
  - [ ] TCP将每一个包标号 接收方对收到的数据包进行排序 把有序数据传送给应用层
  - [ ] 校验和 丢弃校验出错的数据
  - [ ] 丢弃重复的数据
  - [ ] 流量控制：为了防止接收端的缓冲空间不足，当接收端来不及处理数据时，提示发送方降低发送的速率，防止包丢失；
  - [ ] 拥塞控制：当网络拥塞时，减少数据的发送；
  - [ ] ARQ协议：为了实现可靠的传输，每发完一个分组就停止发送，等待对方确认，收到确认后再发送下一个分组；
  - [ ] 超时重传：当TCP发送一个分组后，在规定时间内没有收到对方的确认信息，则重发这个报文段；
- [ ] ARQ协议 自动重传请求（Automatic Repeat-reQuest）
  - [ ] OSI模型中的数据链路层、传输层的错误纠正协议之一；它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输；
  - [ ] 停止等待ARQ协议
    - [ ] 为了实现可靠传输，当TCP发送一个分组后，在规定时间内没有收到对方的确认信息，则重发这个报文段；
    - [ ] 若接收方收到重复分组，则丢弃，但是仍然要发送ACK确认；
    - [ ] 优点：简单
    - [ ] 缺点：信道利用率低 等待时间长
  - [ ] 连续ARQ协议
    - [ ] 发送方维持一个发送窗口，但凡位于发送窗口内的分组，可以连续发送出去，而不需要等待对方确认；接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表示到这个分组为止的所有分组都已经正确收到；
    - [ ] 接收方如果接收到了不连续的分组，比如1,2,3,5,分组4丢失了，那么接收方将会发送一个分组3的ACK确认信息；
    - [ ] 优点：信道利用率高，容易实现，即使确认丢失，也不必重传；
    - [ ] 缺点：不能反映接收方已经正确受到的所有分组信息；比如分组4丢失了，而分组5,6均未丢失，发送方仍然会将4,5,6重传；
- [ ] 滑动窗口和流量控制
  - [ ] 流量控制：接收方为了防止处理超出缓冲空间的数据，主动要求接收方调整发送流量；
  - [ ] TCP使用滑动窗口进行流量控制，流量控制是为了控制发送方速率，保证接收方来得及接受；接收方发送的ACK确认报文中的窗口字段信息，可以用来控制发送方的窗口大小，从而影响发送方的发送速率；将窗口字段设置为0，则发送方不能发送数据；
- [ ] 拥塞控制
  - [ ] 拥塞控制：发送方为了防止网络负荷过大，主动调整自身发送流量；
  - [ ] 为了进行拥塞控制，TCP发送方维持一个拥塞窗口；发送方根据拥塞窗口和接收方的流量控制窗口，取较小值来决定发送数据量；
  - [ ] 拥塞控制的四种算法：
    - [ ] 慢开始：由小到大地提高拥塞窗口的大小，以试探当前网络的用色情况；cwnd的初始值为1，试探1次（传播1次），将拥塞窗口的长度加倍；慢开始算法的思想是，一开始发送数据时，不清楚当前网络的情况；
    - [ ] 拥塞避免：每完成1次传播，将cwnd的长度+1；算法思想是，让拥塞窗口缓慢增大；
    - [ ] 快重传与快恢复（FRR, fast retransmit and recovery）：在不使用FRR的情况下，如过数据包丢失，则传输将会暂停；有了FRR的情况下，当有包丢失时不暂停，接收方只有当收到3个重复确认时，才会假定确认指出的数据段丢失，并对其进行重传；FRR在有单独的数据包丢失时，效率是最高的；当多个数据包在短时间内丢失时，则不能很有效地工作；

#### 在浏览器中输入URL->显示主页的过程

- [ ] 1）查找域名的IP地址：
- [ ] 2）向web服务器发送http请求
- [ ] 3）服务器请求处理
- [ ] 4）服务器发回HTML响应
- [ ] 5）浏览器显示HTML
- [ ] 解析:
  - [ ] 1使用了DNS协议
  - [ ] 2-5是客户端（浏览器）与服务端（web服务器）之间的进程交互，使用了TCP/IP网络模型中的主要协议，包括HTTP（访问HTML网页）、TCP（传输层建立连接）、IP（网络层）、OPSF（IP数据包在路由器之间的传输协议）、ARP（网络层、地址解析协议，将ip地址转换为mac地址）

- [ ] http状态码
  - [ ] 1xx:信息性状态码 接收到的请求正在处理
  - [ ] 2xx:成功状态嘛 请求正常处理完毕
  - [ ] 3xx:重定向状态码 需要进行附加额外操作以完成请求
  - [ ] 4xx:客户端错误 服务器无法处理请求
  - [ ] 5xx:服务器错误 服务器处理请求出错
- [ ] http长连接 短连接
  - [ ] 短连接
    - [ ] 定义：指客户端与服务器的每一次HTTP操作，都会建立TCP连接；
    - [ ] HTTP/1.0中 默认使用短连接
  - [ ] 长连接
    - [ ] 定义：指客户端与服务器建立TCP连接之后，该连接会维持一段时间；该连接不会永久维持，在服务器端可以设置保持时间；
    - [ ] HTTP/1.1起 默认使用长连接
- [ ] HTTP如何保存用户状态
  - [ ] html是无状态的协议
  - [ ] 使用Session和Cookie来跟踪浏览器用户身份；Session用于服务器端，Cookie用于浏览器端；
  - [ ] 服务器端可以使用Session来保存用户状态，但是无法区分每一次请求是来自于哪一个用户；
  - [ ] 客户端使用Cookie来保存用户信息，通常在Cookie中附加一个Session ID来进行跟踪；
  - [ ] 由于Session在服务器端，它的安全性比Cookie更高；如果要在Cookie中存储敏感信息，则要进行加密；
- [ ] HTTP 1.0与1.1的区别
  - [ ] 1)长连接与短连接
  - [ ] // TODO

#### HTTPS与HTTP的区别

- [ ] HTTPS定义：
  - [ ] HTTPS (Hypertext Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道；
  - [ ] HTTPS在HTTP的基础上，加入了SSL层；默认使用443借口；
- [ ] SSL
  - [ ] 使用非对称加密 进行密钥协商
  - [ ] 使用对称加密 通过协商后的密钥 进行数据传输
- [ ] HTTPS的作用：
  - [ ] HTTP是明文传输的协议，数据可能被中间人窃听、篡改；
  - [ ] HTTPS使用SSL层，对传输的数据进行加密；
- [ ] 中间人攻击：
  - [ ] HTTP数据包在传输的过程中，被中间人截获、篡改；
  - [ ] 可能导致HTTP请求出错，或者返回的页面中加入了恶意代码（广告）；
- [ ] HTTPS流程：
  - [ ] 1） 建立连接，获取证书：
    - [ ] 客户端先通过SSL握手和服务器建立连接，然后将自己可实现的加密算法和第1个随机数，发送给服务端；
    - [ ] 服务器选择一种加密算法，使用私钥报文hash值加密，生成签名；将证书（签名和公钥）和第2个随机数，发送给客户端；
  - [ ] 2）证书认证
    - [ ] 客户端接受证书和公钥，使用公钥将签名解密，通过第三方机构CA来判断证书的有效性；保证证书中的域名是客户端正在连接的域名；
    - [ ] 若认证通过，客户端生成第3个随机数，并通过公钥加密，发送给服务器；
    - [ ] 服务器收到第3个随机数，用私钥解密；
    - [ ] 客户端、服务端都知道3个随机数，但是中间人只知道前2个随机数；
  - [ ] 2）数据加密和传输
    - [ ] 客户端和服务端，均使用3随机数生成密钥，进行对称加密，进行数据传输；
- [ ] 对称加密：
  - [ ] 加密和解密使用同一个密钥
  - [ ] f(x)=y 并且 f(y)=x ，f是对称加密；
  - [ ] 有性质 f(f(x))=x
- [ ] 非对称加密：
  - [ ] 加密和解密使用不同的密钥
  - [ ] f(x)=y 并且 g(y)=x，f为公钥，g为私钥；
  - [ ] 性质：公钥和私钥互为逆运算
    - [ ] f(g(y))=y，g(f(x))=x
- [ ] 证书：
  - [ ] 采用非对称加密的情况下，需要确保公钥是服务器提供的，而不是中间人伪造的公钥；
  - [ ] 因此，需要第三方机构CA（Certificate Authority）提供的数字证明，即认证；
  - [ ] 证书包含两样东西，公钥+数字签名；

#### HTTP

##### 请求报文

- [ ] http请求报文由“请求行（resuest line）”、“请求头（header）”和”请求体（body）“组成

  ![](https://pic4.zhimg.com/80/v2-0004258bd5cd7513f175c093a69b8777_1440w.jpg)

  - [ ] 1）请求行 包含请求方法、URL、协议版本

    - [ ] ```
      POST /chapter17/user.html HTTP/1.1
      ```

    - [ ] 1.1）请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE

    - [ ] 1.2）URL 即请求地址

    - [ ] 1.3）协议版本 即http版本号

  - [ ] 2）请求头 包含请求的附加信息，由key/value对组成，每行一对，使用：分隔；需要注意的内容：

    - [ ] keep-alive 是否保持长连接

  - [ ] 3）请求体 

    - [ ] 不是所有请求都有请求体

##### 响应报文

- [ ] 响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。

  ![](https://pic4.zhimg.com/80/v2-b93bd482283252e731ed01355e9c585f_1440w.jpg)

  - [ ] 1）响应行 包括协议版本，状态码，状态码描述

    - [ ] 状态码：

      - 1xx：指示信息--表示请求已接收，继续处理。
  - 2xx：成功--表示请求已被成功接收、理解、接受。
    - 3xx：重定向--要完成请求必须进行更进一步的操作。
    - 4xx：客户端错误--请求有语法错误或请求无法实现。
    - [ ] 5xx：服务器端错误--服务器未能实现合法的请求。

- [ ] 转发与重定向

  - [ ] 转发：client向server1发送request，server1将请求转发到server2,server2将资源发送给server1,server1将请求发送给client；
  - [ ] 重定向：client向server1发送request，server1发送重定向返回码给client，client根据重定向信息，向server2发送request，server2将资源发送给client；

##### GET和POST的区别 // TODO

#### RESTful

- [ ] 幂等
  - [ ] HTTP/1.1中对幂等性的定义是：一次和多次请求某一个资源对于资源本身应该具有同样的结果（网络超时等问题除外）。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。

- [ ] GET
  - [ ] 用来获取资源；
  - [ ] 幂等，不会对资源做修改（设计上幂等，实现上不一定幂等）；
  - [ ] 由于幂等，可以对GET请求的数据做缓存；缓存可以在浏览器上（减少请求）、代理上（nginx）以及server端；
  - [ ] 是否有body：
    - [ ] 浏览器
      - [ ] 默认是没有body的；
    - [ ] 接口实现
      - [ ] 是可以有body的；`
- [ ] POST
  - [ ] 用来新建（更新）资源；
  - [ ] 非幂等（设计上非幂等，实现上幂等）；
  - [ ] body：
    - [ ] 浏览器
      - [ ] 主要有2种格式
      - [ ] 1）在URL上带上数据 application/x-www-form-urlencoded用来传输简单的数据，大概就是"key1=value1&key2=value2"这样的格式；
      - [ ] 2）传文件，会采用multipart/form-data格式；
- [ ] PUT 用来更新资源
- [ ] DELETE 用来删除资源

#### 从url出入到页面展现 到底发生了什么

- [ ] 0）URL：统一资源定位符
- [ ] 1）DNS解析（域名解析）
  - [ ] DNS解析提供通过域名查找IP地址的服务
  - [ ] 浏览器如何通过域名来查找IP：
    - [ ] 1. 浏览器缓存
      2. 操作系统缓存
      3. 路由缓存
      4. ISP提供的DNS服务器
      5. DNS根服务器（.com)
      6. 根服务器递归向下级DNS服务器发出请求(.baidu)
- [ ] 2）TCP连接：三次握手
- [ ] 3）发送HTTP请求
- [ ] 4）服务器处理请求并返回HTTP报文
- [ ] 5）浏览器解析、渲染页面
  - [ ] 浏览器解析渲染页面分为五个步骤：
    - [ ] 5.1）根据HTML解析出DOM树；
      - [ ] 使用深度优先遍历；
      - [ ] 如果遇到script标间，则DOM树会暂停构建，直到脚本执行完毕；
    - [ ] 5.2）根据CSS解析生成CSS规则树；
    - [ ] 5.3）结合DOM数和CSS规则树，生成渲染树；
    - [ ] 5.4）根据渲染数计算每一个节点的信息；
    - [ ] 5.5）根据计算好的信息，绘制页面；
- [ ] 6）断开连接：四次挥手
- [ ] 7）长连接：如果浏览器或者服务器在头信息中加入了“Connection：keep-alive”，那么TCP连接在发送后仍然保持打开状态；