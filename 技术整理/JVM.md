#### JVM

##### Java内存区域

- [ ] 线程私有的部分：
  - [ ] 1）程序计数器 Program Counter Register
  - [ ] 2）虚拟机栈 VM Stack
  - [ ] 3）本地方法栈 Native Method Stack
- [ ] 线程共享的部分：
  - [ ] 1）堆 Heap
  - [ ] 2）方法区 Method Area（jdk1.8之前）
  - [ ] 3）直接内存 Direct Memory（jdk1.8之后，元空间Metaspace位于直接内存）
- [ ] 各部分介绍
  - [ ] 1）程序计数器
    - [ ] 存储当前线程运行的字节码行号；
    - [ ] 主要作用：
    - [ ] 1）解释器通过改变程序计数器，依次读取指令，实现代码的流程控制；顺序执行、选择、循环、异常处理等；
    - [ ] 2）多线程情况下，线程切换之后，根据程序计数器来判断原先的程序执行到哪一行；
  - [ ] 2）虚拟机栈
    - [ ] 存放方法的参数以及局部变量和引用；
    - [ ] 虚拟机栈会产生两种Error：
      - [ ] 1）StackOverFlowError 当虚拟机栈不能动态扩展，那么当线程请求栈的深度超过最大限度，会抛出该错误；
      - [ ] 2）OutOfMemoryError 当虚拟机栈的内存大小允许动态扩展，那么当JVM的内存不足时，抛出该错误；
  - [ ] 3）本地方法栈
    - [ ] 为虚拟机使用到的Native方法服务；
    - [ ] 与虚拟机栈类似，虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为虚拟机执行Native方法服务；
    - [ ] HotSpot虚拟机中，虚拟机栈与本地方法栈合二为一；
    - [ ] 栈帧中保存局部变量表、操作数栈、动态链接、出口信息；
    - [ ] 也会出现StackOverFlowError和OutOfMemoryError；
  - [ ] 4）堆 
    - [ ] 存放对象实例，几乎所有的对象实例以及数组都在堆中分配；
    - [ ] 是虚拟机内存中的最大的部分，为所有线程共享；
    - [ ] 又称GC堆；垃圾回收使用了分代垃圾回收算法，因此Java堆还可以分为：
      - [ ] 新生代：Eden空间、From Survivor（S0）、To Survivor（S1）；
      - [ ] 老年代（tentired）
    - [ ] 进一步的堆划分，是为了更好地进行内存回收；
    - [ ] 大部分情况，新对象会进入Eden区，一次新生代垃圾回收后，如果对象存活，则会进入S0或者S1，并且对象年龄+1；当对象年龄增加到一定程度（默认15），则会被晋升到老年代；
  - [ ] 5）方法区
    - [ ] 存储已被虚拟机加载的类信息、常量、静态变量、JIT编译后的代码；
    - [ ] 为所有线程共享；
    - [ ] 又叫Non-Heap（非堆），为了与Java堆区分出来；
    - [ ] 永久代 方法区也被称为永久代，是HotSpot独有的；
    - [ ] 常用参数：
      - [ ] -XX:PermSize=N // 方法区（永久代）初始大小
      - [ ] -XX:MaxPermSize=N // 方法区（永久代）最大大小，超过这个值将会抛出OutOfMemoryError错误
  - [ ] 6）元空间
    - [ ] JDK 1.8 使用了元空间代替方法区；
    - [ ] 元空间使用直接内存；
    - [ ] 为什么使用元空间代替方法区：
      - [ ] 方法区在运行时内存空间，其空间大小不可扩展；
      - [ ] 元空间使用直接内存，只受主机物理内存的限制；
  - [ ] 7）运行时常量池
    - [ ] JDK1.7及之后的版本，将运行时常量池从方法区移到堆中；
    - [ ] 用于存放编译时产生的各种字面量和符号引用；
    - [ ] 常量池包含内容：
      - [ ] 1）字面量
        - [ ] 1.1）文本字符串
        - [ ] 1.2）final限定的常量
        - [ ] 1.3）基本数据类型缓存值
        - [ ] 1.4）其他
      - [ ] 2）符号引用
        - [ ] 2.1）类和结构的完全限定名
        - [ ] 2.2）字段名称和描述符
        - [ ] 2.3）方法名称和描述符
  - [ ] 8）直接内存
    - [ ] JDK1.4中引入NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓存区（Buffer）的I/O方式；
    - [ ] 使用Native函数库直接分配堆外内存；
    - [ ] 使用一个存储在Java堆中的DirectByteBuffer对象最为堆外内存的引用进行操作；

##### Java对象创建过程

- [ ] 大致流程：
  - [ ] 1）类加载检查
    - [ ] 遇到new指令时，首先在常量池中寻找类的符号引用，并检查这个符号引用对应的类是否被加载、解析和初始化；如果没有，则必须先执行相应的类加载过程；
  - [ ] 2）分配内存
    - [ ] 通过类加载检查之后，接下来为新生对象分配内存；
    - [ ] 分配方式有“指针碰撞”和“空闲列表”两种，具体由JVM决定；
    - [ ] 选择哪种分配方式，取决于Java堆内存是否规整；
    - [ ] Java堆内存是否规整，取决于GC收集器的算法是“标记-清楚”还是“标记-整理”（也称“标记-压缩”）；
    - [ ] 分配内存算法
      - [ ] 1）指针碰撞
        - [ ] 使用场合 堆内存规整情况下（没有内存碎片）
        - [ ] 原理 用过的内存放到一遍，没有用过的内存放到另一边，使用分界值指针标记，保留指针左侧内存，忽略指针右侧内存；
        - [ ] GC收集器：Serial、ParNew
      - [ ] 2）空闲列表
        - [ ] 使用场合 堆内存不规整的情况下
        - [ ] 原理 虚拟机维护一个列表，该列表记录那些内存块是可用的，分配时找一块足够大的内存块来划分给对象实例，并更新列表记录；
        - [ ] GC收集器：CMS
    - [ ] 内存分配的并发问题
      - [ ] 多线程进行对象创建时，要保证线程安全；
      - [ ] JVM使用两种方式保证线程安全：
        - [ ] 1）CAS+失败重试
        - [ ] 2）TLAB 每个线程都预先在Eden区分配一段内存空间，JVM在分配内存时，现在TLAB分配，如果TLAB空间用尽，则再使用CAS进行内存分配；
  - [ ] 3）初始化零值
    - [ ] 分配内存之后，将内存空间的初始化为零值（不包括对象头）；
    - [ ] 该操作保证对象可以不赋初值直接使用；
  - [ ] 4）设置对象头
    - [ ] 初始化零值后，JVM对对象做一些必要的设置；
    - [ ] 比如这个对象是哪个类的实例（指向类对象的指针）；如何才能找到类的元数据信息；对象的HASH码；对象的GC分代年龄；
  - [ ] 5）执行init方法
    - [ ] 上面的工作完成之后，执行<init>方法（先执行非静态代码区，再执行构造方法），把对象按照程序员的意愿进行初始化；

##### 两种对象的访问定位方式

- [ ] 使用句柄 和 直接指针
  - [ ] 1）使用句柄
    - [ ] java堆中将维护一个句柄池；
    - [ ] java栈中的引用，指向句柄池中的句柄；
    - [ ] 句柄包含了对象实例数据的地址（java堆中），以及对象类数据的地址（方法区/元空间）；
    - [ ] 句柄存储的地址数据较为稳定，对象被移动（GC）时只需要修改句柄，而不需要修改引用（reference）；
  - [ ] 2）直接指针
    - [ ] java栈中的引用直接指向实例数据的地址（java堆中）；
    - [ ] 根据实例的对象头部分信息，寻找类数据的地址（方法区/元空间）；
    - [ ] 访问速度快，比使用句柄的方法节省了一次指针定位的时间开销；
    - [ ] 缺点：GC时需要改变所有的引用； 

##### 堆内存中对象分配的基本策略

- [ ] 对象优先分配到eden区；
- [ ] 大对象直接进入老年代；
- [ ] 经历过1次GC并且存活的对象，进入其他新生代；
- [ ] 长期存活的对象将进入老年代；

##### Minor GC 与 Full GC

- [ ] 何时进行GC：新生对象一般在Eden区分配，当Eden区内存空间不足时，将会触发Minor GC；

- [ ] 新生代GC（Minor GC）
  - [ ] 指发生在新生代的垃圾回收过程；
  - [ ] Minor GC 非常频繁，回收速度也快；
- [ ] 老年代GC（Major/Full GC）
  - [ ] 指发生在老年代的GC；
  - [ ] Full GC 通常伴随着至少1次Minor GC；
  - [ ] Full GC 的速度一般比 Minor GC 慢10倍以上；

##### 判断对象死亡的两种方法

- [ ] 对象死亡 指堆中的对象不能再被任何途径使用
- [ ] 两种方法：
  - [ ] 1）引用计数法
    - [ ] 使用一个计数器，记录某对象实例被引用的次数；
    - [ ] 计数器为0的对象就不可能再被使用；
  - [ ] 2）可达性分析法
    - [ ] 选择某些对象作为 GC Roots，分析对象的引用链；
    - [ ] 如果某对象没有被任何GC Roots引用链连接到的话，则证明此对象是不可用的；
    - [ ] 可作为 GC Roots 的对象：
      - [ ] 局部变量
      - [ ] 类变量（静态变量）
      - [ ] 常量
      - [ ] 本地方法栈中的引用
      - [ ] 已启动且未停止的线程

##### 强引用、软引用、弱引用、虚引用

- [ ] // TODO

##### 废弃常量回收

- [ ] 同死亡对象回收
- [ ] 废弃常量：没有被任何引用对象引用带的常量；

##### 如何判断一个无用的类

- [ ] 同时满足以下三个条件：
  - [ ] 1）该类的所有实例均被回收；
  - [ ] 2）加载该类的 ClassLoader 被回收；
  - [ ] 3）该类的对应 java.lang.Class 对象没有被任何地方被引用，无法在任何地方通过反射来访问该类；
- [ ] 无用的类未必会被回收；

##### 各类GC算法

- [ ] 1）标记-清除 算法
  - [ ] 算法分为“标记”和“清除”两个阶段
    - [ ] 标记阶段 标记出所有需要回收的对象
    - [ ] 清除阶段 统一回收被标记的对象
  - [ ] 这是最基础的GC算法；后续算法都是“标记-清除”算法的改进；
  - [ ] 缺陷：
    - [ ] 效率问题
    - [ ] 空间问题 标记清除后会产生大量不连续的碎片
- [ ] 2）复制算法
  - [ ] 将所有可用的内存分为两块；
  - [ ] 同一时刻只使用其中一块内存；
  - [ ] GC时，将使用中的一块内存，标记所有的存货的对象，按顺序复制到另一块内存中；
  - [ ] 复制完之后，把使用的弓箭一次性清理掉；
  - [ ] 优点：清理完之后的内存空间是连续的；
  - [ ] 缺点：空间效率，同时只能使用一半的内存空间；
- [ ] 3）标记-整理 算法
  - [ ] 先标记所有存活的对象；
  - [ ] 让存活的对象向一端移动；
  - [ ] 清理掉端边界以外的内存空间；
  - [ ] 优点：清理之后的空间是连续的；
- [ ] 4）分代收集算法
  - [ ] 当前主流的GC算法；
  - [ ] 根据对象存活周期不同，将内存分为几块；一般分为新生代和老年代；
  - [ ] 不同年代的区域，可以采用不同的GC方法；
  - [ ] 对于新生代：每次GC将会淘汰大量对象，可以选择复制算法；
  - [ ] 对于老年代：对象存活几率比较高，使用“标记-清除”或者“标记-整理”；不能使用复制算法，因为老年代对象占用空间大，对内存大小的要求高；

##### 常见垃圾回收器

- [ ] 垃圾回收器是GC算法的具体实现
- [ ] 所有的GC过程，都是要暂停所有应用程序线程的；
- [ ] 1）Serial收集器
  - [ ] 串行收集器，在GC时需要暂停其他所有的线程，直到GC结束；
  - [ ] 新生代采用复制算法，老年代采用“标记-整理”算法；
  - [ ] 优点：简单高效
  - [ ] 缺点：GC时间长 暂停应用程序
- [ ] 2）ParNew收集器
  - [ ] 许多Server模式虚拟机的首选；
  - [ ] 能与CMS收集器配合工作；
  - [ ] 本质上与Serial收集器相同，不过GC过程使用多线程并发提高效率；
  - [ ] 优点：效率比Serial高；
  - [ ] 缺点：仍要暂停应用程序；
- [ ] 3）Parallel Scavenge收集器
  - [ ] 在ParNew收集器的基础上，关注吞吐量（运行用户代码的时间/CPU总耗时的时间），即降低GC过程占JVM总运行时间中比例；
  - [ ] 提供很多参数，令用户寻找合适的停顿时间或者最大吞吐量；
- [ ] 4）CMS（Concurrent Mark Sweep）收集器
  - [ ] 该收集器以用户体验为目标，尽可能地降低GC的暂停时间；
  - [ ] 基本上实现了GC线程与用户线程同时工作；
  - [ ] 基于“标记-清除”算法实现；
  - [ ] 算法流程：
    - [ ] 1）初始标记 （使用可达性分析法）暂停所有其他线程，标记GC Roots，记录直接与root相连的对象，速度很快；
    - [ ] 2）并发标记 同时开启GC线程和用户线程，用一个闭包结构去记录可达对象；对象引用可能会被用户线程更新，因此这个算法要跟踪发生引用更新的地方；
    - [ ] 3）重新标记 暂停用户线程，重新标记哪些被用户线程更新的引用位置；
    - [ ] 4）并发清除 开启用户线程，同时GC线程对标记的区域做清扫；
  - [ ] 优点：并发收集，高效，地停顿；
  - [ ] 缺点：
    - [ ] 对CPU资源敏感；
    - [ ] 无法处理浮动垃圾；
    - [ ] 大量空间碎片；
- [ ] 5）G1（Garbage-First）回收器
  - [ ] // TODO

##### 类加载过程

- [ ] 类加载流程如下：
  - [ ] 加载->链接->初始化
  - [ ] 其中“链接”过程可以分为：
    - [ ] 验证->准备->解析
- [ ] 1）加载
  - [ ] 通过全类名获取二进制字节流（.class文件）；
  - [ ] 将二进制字节流（.class文件）中的静态存储结构，转换为方法区的运行时数据结构；
  - [ ] 在内存中生成一个Class对象，作为访问方法区内这些数据的访问入口；
  - [ ] 使用到了类加载器；
- [ ] 2）连接
  - [ ] 2.1）验证
    - [ ] 对.class文件的文件格式进行校验；
    - [ ] 对元数据进行验证；
    - [ ] 对字节码进行验证；保证语义的合理性；
    - [ ] 对符号引用进行验证；通过全限定名是否可以找到对应的类；符号引用中的访问限定（private，public）是否可以被当前类访问；
  - [ ] 2.2）准备
    - [ ] 为静态变量赋初值；
    - [ ] 8种基本类型初值为0；
    - [ ] 引用类型初值为null；
    - [ ] 常量的初值为给定字面量；
  - [ ] 2.3）解析
    - [ ] 将常量池中的符号引用，转换为直接引用；
    - [ ] 符号引用：通过字符串来标记引用的类；
    - [ ] 直接引用：引用类的Class对象的实际逻辑地址；
- [ ] 3）初始化
  - [ ] 主要对类变量（静态变量）进行初始化；
  - [ ] 判断次类的父类是否已初始化；若为初始化，则优先初始化其父类；
  - [ ] 按顺序执行静态代码块；
- [ ] 类加载器
  - [ ] JVM内置了3个重要的Classloader：
    - [ ] 1）BootstrapClassLoader（启动类加载器） 最顶层的加载器，由C++实现；主要负责%JAVA_HOME%/lib目录下的jar包和类的加载，或者-Xbootclasspath参数指定的路径中的所有类；
    - [ ] 2）ExtClassloader（扩展类加载器） 主要负责%JRE_HOME%/lib/ext目录下的类加载；或者系统变量java.ext.dirs指定路径下的jar包；
    - [ ] 3）AppClassLoader（应用类加载器） 面向用户的加载器，加载当前应用classpath路径下的所有jar包和类；
  - [ ] 自定义加载器
    - [ ] 作用：如果需要对字节码进行加密，那么需要使用自定义加载器，对加密过的字节码进行解密、加载；
- [ ] 双亲委派模型
  - [ ] 目的
    - [ ] 保证Java程序的稳定运行，避免类的重复加载；
    - [ ] 防止Java的核心API被篡改；
    - [ ] 同一个.class文件，被不同的ClassLoader加载时，会产生不同的类；
  - [ ] 流程
    - [ ] 1）类加载器在加载类时，先判断当前类是否已被加载；
    - [ ] 2）若已被加载，则返回；
    - [ ] 3）若未被加载，ClassLoader首先会委托父加载器，通过loadClass方法进行加载；
    - [ ] 4）若父类为null，则委托BootStrapClassLoader进行加载；这是因为BootStrapClassLoader由c++实现，不存在该加载器对应的java类；
    - [ ] 5）若父加载器无法加载此类，则该加载器才会尝试加载此类；
  - [ ] 所有需要加载的类，最终都会经过启动类BootStrapClassLoader；