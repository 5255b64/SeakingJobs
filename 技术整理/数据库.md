# 数据库

---

## 数据库基本概念

### 事务

#### 概念

- 事务，指的是满足ACID特性的一组操作，可以通过commit提交一个事务，也可以通过rollback进行回滚；

#### ACID

- 原子性（Atomicity）
  - 事务操作要么都提交成功，要么全部失败回滚；
  - 回滚可以使用回滚日志（Undo Log）来实现；回滚日志记录了事务执行的修改操作，回滚时只要反向执行这些修改操作即可；
- 一致性（Consistency）
  - 数据库在事务执行前后都白痴一致性状态；
  - 在一致性状态下，所有事务对同一个数据的读取结果都是相同的；
- 隔离性（Isolation）
  - 一个事务所做的修改，在最终提交之前，对其他事务是不可见的；
- 持久性（Durability）
  - 事务一旦提交，其修改的结果将永远地保存到数据库中；
  - 即使数据库发生崩溃，事务执行的结果也不会丢失；
  - 系统崩溃时，可以使用重做日志（Redo log）进行恢复，从而实现持久性；
  - 与回滚日志不同，重做日志记录的是数据页的物理修改；
- 解析：
  - 只有满足一致性，事务的执行结果才是正确的；
  - 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性；
  - 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还要满足隔离性，才能满足一致性；
  - 持久化是为了能应对系统崩溃的情况；
  - 总结：
    - 原子性+隔离性 -> 保证一致性
    - 一致性 -> 保证执行结果正确
    - 持久性 -> 应对系统崩溃

#### AUTOCOMMIT

- 自动提交：当没有使用`START TRANSACTION`来开始一个事务时，默认每一个语句都作为事务，并自动提交。
- MySQL默认采用自动提交

### 并发一致性问题

- 在并发环境下，产生的一致性问题。

#### 丢失修改

- 一个事务的更新操作，被另一个事务的更新操作覆盖掉了；
- （事务的输出结果被覆盖掉）

#### 读脏数据

- 一个事务在运行时，读到了另一个事务未提交的数据；
- （读取到其他事务运行的中间结果）

#### 不可重复读

- 一个事务在运行时，多次读取同一个数据，读取结果不一致；
- 原因是其他事务对该数据作了修改；
- （事务读取的数据被其他事务修改）

#### 幻影读

- 本质属于不可重复读
- 一个事务在运行时，事先读取的数据，在数据库中发生了改变，从而影响该事务后续的操作；
- （不可重复读是读的数据被修改，幻读是读的表中多了/少了一些数据行）

### 封锁 TODO

#### 封锁粒度

- MySQL提供两种封锁粒度
  - 行锁
  - 表锁
- 封锁粒度越小，锁征用的情况就越少，并发程度就越高；
- 但是需要消耗资源，锁的各种操作（获取、释放、检查锁状态）都会增加系统开销；
- 因此，封锁粒度越小，系统开销就越大；
- 选择封锁粒度时，需要在锁开销和并发程度之间进行权衡；

#### 封锁类型

- 1）读写锁
  - 互斥锁（Exclusive），简称X锁，又称写锁；
  - 共享锁（Shared），简称S锁，又称读锁；
  - 有以下规定：
    - 如果对象加了X锁，就可以对其进行读写入操作；加锁期间任何其他事务都不能对该对象加锁；
    - 如果对象加了S锁，可以对其进行读操作；加锁期间，其他事务能对该对象加S锁，但是不能加X锁；
- 2）意向锁
  - 使用意向锁（Intention Locks）可以更容易地支持多粒度封锁；
  -  当存在行锁和表锁的情况下，如果某事务T想对表A加X锁，是十分耗时的；事务T需要遍历表A中的所有行，判断是否有其他事务对某一行加过锁；
  - 意向锁在X/S锁之上，引入了IX/IS锁；IX/IS都是表锁，用来表示一个事务想要在表中的某一行数据上加X锁或者S锁；
  - 有以下规定：
    - 一个事务在获取某数据行对象的S锁之前，必须要获取数据表的IS/锁或者更强的锁；
    - 一个事务在获取某数据行对象的X锁之前，必须要获取数据表的IX锁；

#### 封锁协议

##### 三级封锁协议

1. 一级封锁协议
   - 事务T要修改数据A时，必须要加X锁，直到T结束才释放锁；
   - 可以解决丢失修改问题，因为不能有两个数据同时修改同一个数据，那么事务提交的修改就不会被覆盖；
   - （修改数据前加X锁，确保修改的数据不会被其他事务读/写）
2. 二级封锁协议
   - 在一级的基础上，要求读数据时加上S锁，读取完马上释放S锁；
   - 可以解决读脏数据问题，因为如何一个事务在对数据A进行修改，根据一级封锁协议，会加X锁，那么就不能再加S锁，也就不会读入脏数据。
   - （读取数据前加S锁，确保读取的数据不会被别的事务修改）
3. 三级封锁协议
   - 在二级封锁协议的基础上，要求读数据时加上S锁，直到事务结束才释放锁；
   - 解决不可重复读（幻读）的问题；因为读A并加S锁时，其他事务不能对A加X锁，也就是A不会被修改，避免在读的期间数据发生变化；

##### 两段封锁协议

- 两段封锁协议（2PL），将加锁和解锁分为两个阶段；
- 所有解锁的操作，必须要在所有加锁操作之后；
- 两段封锁协议可以保证冲突可串行化，即并发事务的执行结果，与串行执行结果相同，不会出现并发一致性问题；
- 两段封锁协议，是冲突可串行化的充分条件，但不是必要条件；

#### MySQL隐式与显式锁定

- MySQL的InnoDB存储引擎，采用两段锁协议，会根据隔离级别，在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定；
- InnoDB也可以使用特定的语句进行显示锁定

```sql
SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;
```



### 隔离级别 

|          | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 未提交读 | X    | X          | X    |
| 提交读   | J    | X          | X    |
| 可重复读 | J    | J          | X    |
| 可串行化 | J    | J          | J    |



#### 未提交读（READ UNCOMMITTED）

- 事务中的修改，即使是没有提交，对其他事务也是可见的。

#### 提交读（READ COMMITTED）

- 一个事务只能读取已经移交的事务所做的修改；
- 一个事务做做的修改，在提交之前对其他事务是不可见的；
- （保证了隔离性）
- （解决了脏读的问题）

### 可重复读（REPEATABLE READ）

- 保证同一个事务中多次读取同一数据的结果是一样的。
- （解决了不可重复读的问题）

### 可串行化（SERIALIZABLE）

- 强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题；
- 该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。

## 多版本并发控制 MVCC

- 多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现**提交读**和**可重复读**这两种隔离级别；
- 而**未提交**读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC；
- **可串行化**隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

### 基本思想

- 1）加锁能解决并发一致性问题；
- 2）由于实际场景中，读数量多于写数量，因此引入读写锁，避免不必要的加锁操作，读和读之间不互斥；
- 3）MVCC利用多版本的思想，写操作在新版本快照上执行，读操作在旧版本快照上执行，没有互斥关系；
- MVCC的思想与CopyOnWrite类似。
- **脏读和不可重复读最根本的原因**是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。

### 版本号

- 系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
- 事务版本号 TRX_ID ：事务开始时的系统版本号。

### Undo日志

MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。

例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。

```
INSERT INTO t(id, x) VALUES(1, "a");
UPDATE t SET x="b" WHERE id=1;
UPDATE t SET x="c" WHERE id=1;
```

因为没有使用 `START TRANSACTION` 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。

[![img](https://camo.githubusercontent.com/648b989516b41055bbd1f39ee4b61a6b0a00e0d0114632dceb1c6b91ec39dca6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383136343830383231372e706e67)](https://camo.githubusercontent.com/648b989516b41055bbd1f39ee4b61a6b0a00e0d0114632dceb1c6b91ec39dca6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383136343830383231372e706e67)



INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。

#### 快照与当前读

### ReadView

- Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。

- MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。

##### Record Locks

- 锁定一个记录上的索引，而不是记录本身。

- 如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。

##### Gap Locks

- 锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。

```
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

## Next-Key Locks

- 它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

```
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```

## MySQL

- [ ] InnoDB MySQL使用的事务性数据库引擎

### MySQL结构

- [ ] 1）服务器 Server

  - [ ] 1.1）连接器

    - [ ] 负责与客户端建立连接、权限管理

  - [ ] 1.2）查询缓存

    - [ ] 执行查询语句之前，先查询缓存；如果缓存命中，则直接返回存储的缓存内容；若缓存未命中，则再执行分析器；
    - [ ] 返回查询结果时，要做权限验证；
    - [ ] 查询缓存的效率低下，在MySQL8.0之后被移除；
    - [ ] 每次查询成功之后，要将查询作为key，查询结果作为value，存储在缓存中；
    - [ ] 若MySQL中的表被修改，对应的缓存将会被删除；
    - [ ] 在更改频繁的情况下，缓存会被频繁更新、删除，影响效率；

  - [ ] 1.3）分析器

    - [ ] 先进行词法分析，辨别每个字符串的类型，找出关键字、表名、属性名等；
    - [ ] 然后进行语法分析，判断SQL语句是否符合语法规范；
    - [ ] 对于语法问题进行提示；

  - [ ] 1.4）优化器

    - [ ] 对SQL查询的具体过程进行优化；
    - [ ] 当存在多个索引时，决定使用哪个索引；
    - [ ] 当一个语句具有多表关联（join）的时候，决定表的连接顺序；
    - [ ] 比如：

    ``` sql
    mysql> select * from t1 join t2 using(ID)
     where t1.c=10 and t2.d=20;
    ```

    - [ ] 既可以先从表 t 1 里面取出 c=10 的记录的 ID 值,再根据 ID 值关联到表 t 2,再判断 t 2
      里面 d 的值是否等于 20。
    - [ ] 也可以先从表 t 2 里面取出 d=20 的记录的 ID 值,再根据 ID 值关联到 t 1,再判断 t 1 里
      面 c 的值是否等于 10。

  - [ ] 1.5）执行器

    - [ ] 权限判断 是否对表具有查询权限；
    - [ ] 执行语句，查询表中的数据；

- [ ] 2）存储引擎

  - [ ] 负责数据的存储和提取。其架构是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎；
    - [ ] InnoDB MySQL5.5之后的默认存储引擎
      - [ ] 支持事务、行级锁、外键约束；
    - [ ] MyISAM MySQL5.5之前的默认存储引擎
      - [ ] 不支持事务和外键约束，只有表级锁；
      - [ ] 速度快，占用资源少；
    - [ ] Memory 使用内存来存储数据
      - [ ] 速度快
      - [ ] 如果mysqld崩溃，会丢失所有数据；

#### 索引

- [ ] 作用：
  - [ ] 提高查询效率；
  - [ ] 使用索引来
- [ ] 常见模型：
  - [ ] 1）哈希表
    - [ ] 使用数组快速定位；
    - [ ] 不是有序的，区间查询速度较慢；
    - [ ] 适合等值查询，Memcached以及其他的NoSQL；
  - [ ] 2）有序数组
    - [ ] 使用二分搜索进行查询；
    - [ ] 在等值查询和范围查询场景中的性能都很优秀；
    - [ ] 查询效率
    - [ ] 适用于静态存储引擎；
  - [ ] 3）搜索树
    - [ ] 数的字节点保证从左到右递增；
    - [ ] 一般不用二叉数，而是多叉数，是为了降低数的高度，减少查询时间；
- [ ] InnoDB索引模型
  - [ ] 使用B+树
  - [ ] 索引分类
    - [ ] 1）主键索引
      - [ ] 叶子结点存储的是正行数据
      - [ ] 又称聚簇索引（cluster index）
    - [ ] 2）非主键索引
      - [ ] 叶子结点存储的是主键（secondary index）
      - [ ] 又称二级索引
  - [ ] 回表
    - [ ] 查询时应尽量使用主键；
    - [ ] 主键查询：直接使用主键索引，返回整行数据；
    - [ ] 非主键索引：先使用非主键进行索引，查询到主键，然后使用主键索引，返回整行信息；这个过程叫“回表”；
    - [ ] 基于非主键索引的查询，需要多扫描一棵索引数，耗时更长；
- [ ] 索引维护
  - [ ] B+树的插入、删除操作较为复杂，涉及到页分裂、合并的操作，较为耗时；
  - [ ] 自增主键
    - [ ] 向B+树插入新纪录时，不指定ID，而是由系统指定自增的ID；
    - [ ] 这种情况下，新记录默认插入到B+树末尾，不会触发叶子结点的分裂；
    - [ ] 如果用业务逻辑字段做主键，往往不能保证插入的有序性，写数据成本较高；
- [ ] 覆盖索引
  - [ ] 使用索引进行搜索时，只需返回主键值，而不需要进行回表；
  - [ ] 覆盖索引可以减少搜索次数，显著提升查询性能；
- [ ] 最左匹配原则
  - [ ] B+树中的结点排序，是根据索引顺序的，优先以最左索引排序，当最左索引值相同时，再按顺序使用后续索引值进行排序；
  - [ ] 当使用联合索引 index （A，B，C）时，优先在查询语句中查找最左索引项（A）的等值查询（=或者in），然后查询第二个索引项（B）的等值查询，以此类推；
  - [ ] 只能对等值索引（=或者in）进行查找，一旦遇到范围查询，就无法使用后续索引项；
  - [ ] 索引项在select语句中的出现顺序，对结果没有影响；MySQL的优化器会对条件的顺序做优化；
- [ ] 索引的设计原则
  - [ ] 经常需要查询的字段 要建立索引
  - [ ] 索引的数量尽量少 减少索引表的占用空间 以及索引表增删的开销
  - [ ] 索引项的数据量要小 尽量使用占空间小的数据类型
  - [ ] 使用区分度高的字段作为索引
  - [ ] 最左前缀匹配原则
    - [ ] 区分度高的字段放左面
    - [ ] 使用频繁的字段（等值查询）放左面

#### 事务

- [ ] 定义：一组原子性的操作，要么都执行，要么都不执行；
- [ ] 在MySQL中执行查询、修改语句，默认会包装成事务，并且直接COMMIT；
- [ ] 显式事务：使用BEGIN开始一个事务；使用ROLLBACK回滚事务；使用COMMIT确认事务，结束一段事务的编写；
- [ ] 四大特性（ACID）
  - [ ] 1）原子性（Automicity） 事务的操作不可分割，要么都执行，要么都不执行；
  - [ ] 2）一致性（Consistency） 执行事务前后，数据保持一致；多个事务对同一数据的读取结果是相同的；
  - [ ] 3）隔离性（Isolation)  并发访问数据库时，一个用户的事务不会被其他事务所干扰；并发事务之间的数据库是独立的；
  - [ ] 4）持久性（Durability） 一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障，对数据也没有影响；
- [ ] 并发事务带来的问题：
  - [ ] 1）脏读（Dirty read） 当数据被修改后，但是没有提交之前，被另一个事务读了；
  - [ ] 2）丢失修改（Lost to modify） 一个事务修改了数据之后，但是没有提交之前，被另一个事务修改并覆盖了；
  - [ ] 3）不可重复读（Unrepeatable read） 一个事务多次读取相同数据时，前后数据值不相同的情况；
  - [ ] 4）幻读（Phantom read） 一个事务多次读取相同表中的内容时，表中有新增行或者删除行的情况；
- [ ] 事务隔离级别
  - [ ] InnoDB默认隔离级别：可重复度（REPEATABLE-READ） 
  - [ ] 1）读取未提交（READ-UNCOMMITTED） 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读、不可重复读；
  - [ ] 2）读取已提交（READ-COMMITTED） 允许读取并发事务已提交的数据，可以阻止脏读，但仍可能发生幻读或者不可重复读；
  - [ ] 3）可重复度（REPEATABLE-READ） 对同一字段的多次读取结果都是一致的，除非数据是被事务自己修改的；可以阻止脏读和不可重复读，但是不能阻止幻读；
  - [ ] 4）可串行化（SERIALIZABLE） 最高的隔离级别，所有事务串行执行；该级别可以防止脏读、不可重复读和幻读；
  - [ ] 在分布式事务的情况下，InnoDB一般使用可串行化（SERIALIZABLE）隔离级别；

#### 大表优化

- [ ] 常见的优化措施：
  - [ ] 1）限定数据的范围 读取数据值务必禁止不带任何限制数据范围条件的查询语句；
  - [ ] 2）读写分离 将数据库拆分，主库负责写，从库负责读；
  - [ ] 3）垂直分区 根据数据库中数据表的相关性，按列将大表拆分为小表；
    - [ ] 优点：可以使得列数据变少，减少查询时的I/O次数，简化表的结构；
    - [ ] 缺点：主键冗余，需要在应用层进行额外的join操作；
  - [ ] 4）水平分区 保持数据表结构不变，使用某种策略将存储数据分片，每一片数据分散到不同的表或者库中；
    - [ ] 水平拆分最好分库
    - [ ] 数据库分片会带来很对问题，数据拆分会提高逻辑、部署、运维的复杂度；

- [ ] 池化设计思想 数据库连接池
  - [ ] 数据库连接的本质，是socket连接，基于TCP协议，是有连接的；
  - [ ] 池化思想类似于缓存，将新的数据库连接保存在连接池中，当再次使用时从连接池中获取，而不需要再次建立新的连接；
  - [ ] 连接池减少了用户等待建立与数据库之间的连接的时间；
- [ ] 分库分表之后 如何选取id主键
  - [ ] 1）UUID 不适合作为主键，因为太长了，影响性能；
  - [ ] 2）数据库自增id 两台数据库设置不同的自增步长或者初始值，生成不重复的ID；缺点是每个数据库都需要独立部署，成本高，并且存在性能瓶颈；
  - [ ] 3）利用redis生成id // TODO
  - [ ] 4）雪花算法（snowflake） 源自twitter，使用64位long数据作为id，记录符号（1位）、时间戳（41位）、机器id（10位）、序列号（12位）信息；
  - [ ] 5）号段模式 从数据库向主数据库申请号段（比如(0,1000])，当号段内id使用完后，再次向主数据库申请新的号段；主数据库相当于索引；

#### SQL语句在MySQL中如何执行

- [ ] MySQL基本框架
  - [ ] 1）客户端 
  - [ ] 2）Server端
    - [ ] 2.1）连接器 身份认证和权限相关；
    - [ ] 2.2）查询缓存 （8.0版本后移除）执行查询语句时，先查询缓存；
    - [ ] 2.3）分析器 词法分析 语法分析
    - [ ] 2.4）优化器 MySQL会按照它认为的最优方案进行查询
    - [ ] 2.5）执行器 执行查询语句，从存储引擎返回数据；
    - [ ] 2.6）日志Binlog
  - [ ] 3）存储引擎 负责数据的存储和读取，是可替换的插件式的；其中InnoDB引擎自带redolog日志模块；
- [ ] 查询过程 // TODO
- [ ] 更新过程 // TODO

#### MySQL优化

- [ ] 一条SQL语句查询过慢 原因是什么
  - [ ] 分两种情况：偶尔很慢、一直很慢
  - [ ] 1）偶尔很慢
    - [ ] 1.1）数据库在刷新脏页（flush）
      - [ ] 脏页：内存中的数据和磁盘中的数据不匹配的情况；
      - [ ] InnoDB在写数据时，会将数据先暂存到内存中，存在redo log日志里；
      - [ ] 什么情况下会刷新脏页：
        - [ ] redo log写满了 要将数据同步到磁盘；
        - [ ] 内不能不够用，脏页被选中淘汰，淘汰之前要先将数据同步到磁盘；
    - [ ] 1.2）拿不到锁
      - [ ] 所需的数据的表级锁或者行级锁被占用；
  - [ ] 2）一直很慢
    - [ ] 2.1）字段没有使用索引
    - [ ] 2.2）字段有索引，但是查询时没有用到索引；如果查询时不是直接使用字段，而是字段的表达式，则不会使用索引；
    - [ ] 2.3）表有索引，但是数据库选错了索引；

#### MySQL调优

- [ ] // TODO

#### MyISAM与InnoDB

|            | MyISAM | InnoDB             |
| ---------- | ------ | ------------------ |
| 事务       | ×      | √                  |
| 数据行锁   | ×      | √                  |
| 数据表锁   | √      | √                  |
| 外键约束   | ×      | √                  |
| 全文索引   | √      | ×                  |
| 表空间大小 | 较小   | 较大 是MyISAM的2倍 |

- [ ] InnoDB
  - [ ] 安全性高
  - [ ] 支持事务处理
  - [ ] 多表多用户操作
- [ ] MyISAM
  - [ ] 节约空间
  - [ ] 速度快

- [ ] InnoDB文件
  - [ ] *.frm文件（ibd） data/[数据库名]/[表明].frm 表结构定义文件
  - [ ] data/ibdata*文件 
- [ ] MyISAM文件
  - [ ] *.frm(sdi) 表结构定义文件
  - [ ] *.MYD 数据文件（data）
  - [ ] *.MYI 索引文件（index）

### MySQL日志

#### bin log

#### redo log

#### undo log

## Redis

### 基础

- [ ] Redis是一个存储在内存中的key-value缓存数据库，读写速度非常快，广泛应用于缓存方向；redis也经常用来做分布式锁；redis支持事务、持久化、LUA脚本、LRU驱动事件、多种集群方案；
- [ ] 高性能与高并发
  - [ ] 高性能：使用缓存，只有第一次从磁盘中读取速度较慢，后续如果命中缓存，从缓存中读取速度较快；
  - [ ] 高并发：可以考虑将数据库中的部分数据转移到内存，这样可以提高能够承受的请求数；
- [ ] 使用redis不需要用户验证，但是可以设置密码；
- [ ] 使用“GET”、“SET”关键字进行string类型变量的存取，“SET str1 abc”表示将字符串“abc”赋给变量str1，“GET str1”将返回变量str1的值“abc”；
- [ ] 使用“HMGET”、“HMSET”、“HGET”、“HSET”关键字进行hash类型变量的存取，“SET hash1 field1 a field2 b”表示hash对象赋给变量hash1，这个hash对象有两个字段，字段field1的值为“a”，字段field2的值为“b”；
- [ ] redis支持发布订阅功能
  - [ ] SUBSCRIBE channel [channel ...]
    订阅给定的一个或多个频道的信息。
  - [ ] PUBLISH channel message
    将信息发送到指定的频道。
- [ ] redis事务
  - [ ] 使用MULTI关键字标记事务开始，随后所有命令都会进入事务队列，返回QUEUED；
  - [ ] 使用EXEC关键字表示事务编写结束，开始执行；队列中的命令按顺序执行；
  - [ ] 事务中任意命令执行失败，其他命令仍然会执行；
  - [ ] 在事务执行的过程中，其他客户端提交的命令请求不会插入到事务执行命令序列中；
  - [ ] 单个redis命令是原子性的，但是redis事务不是原子性的；
  - [ ] redis事务没有失败回滚；
- [ ] redis支持LUA脚本
- [ ] redis持久化
  - [ ] 数据将会保存在dump.rdb文件中
  - [ ] 数据恢复，只需要将备份的dump.rdb文件移动到redis安装目录，并重新启动服务即可；
- [ ] redis的数据类型：
  - [ ] 1）string 字符串，二进制安全，可以用于存储图像或者序列化对象，最大能存储512M；
  - [ ] 2）hash 字典；
  - [ ] 3）list
  - [ ] 4）set
  - [ ] 5）sorted set
- [ ] redis命令
  - [ ] 1）DEL key 删除对象
  - [ ] 2）DUMP key 序列化对象
  - [ ] 3）EXISTS key 判断对象是否存在，存在则返回1，不存在则返回0；
  - [ ] 4）EXPIRE key seconds 为对象key设置过期时间seconds（秒），超时则会DEL key；
  - [ ] 5）EXPIREAT key timestamp 为对象key设置过期时间（时间戳） 
  - [ ] 6）PEXPIRE key milliseconds 为对象key设置过期时间（毫秒）

#### 缓存雪崩和缓存穿透

- [ ] 缓存雪崩
  - [ ] 定义：指缓存在同一时间内大面积失效，数据库将会积累过多的请求，造成短时间承受大量请求而雪崩；
  - [ ] 解决方案：
    - [ ] 事前：保证redis集群的高可用性，发现宕机需要尽快补上；选择合适的内存淘汰策略；
    - [ ] 事中：缓存+限流/降级 避免MySQL崩掉
    - [ ] 事后：利用redis持久化机制，利用磁盘中保存的数据，尽快恢复缓存；
- [ ] 缓存穿透
  - [ ] 定义：大量请求中的某个key在redis与MySQL都不存在，导致根本没有经过缓存，大量请求落到MySQL中；
  - [ ] 解决方法：
    - [ ] 1）对无效的key进行缓存，并设置过期时间，避免使用MySQL进行查询；并且对无效的key设置过期时间，防止redis雪崩；
    - [ ] 2）布隆过滤器，介于服务端与redis之间，实现1）中的效果；使用hash表，每个key占1位，不处理hash碰撞，因此结果的准确性不为100%；
- [ ] 如何解决redis的并发竞争key问题
  - [ ] 使用分布式锁（zookeeper和redis都可以实现），即多台服务器对相同资源进行请求时，需要加锁；
  - [ ] redis的分布式锁实现：
    - [ ] 1）SETNX key value命令 如果不存在key，则创建key，赋值value(不重要，可以存放锁的获取时间)，返回1；如果已存在key，则返回0；这个key值就可以当做分布式锁；
    - [ ] 2）加锁、释放锁需要服务器端进行操作，如果redis宕机，可能造成锁未被释放，但是持有锁的进程不能释放锁而中断；对此，要对锁设置有效时间EXPIRE；
    - [ ] 3）GETSET key value命令，如果某个锁被占用的时间过长，其他服务器可以使用GETSET命令抢占锁，并根据value值（锁被抢占的时间是否过期）判断是否成功拿到锁；

#### 保证缓存与数据库的一致性

- [ ] 1）将缓存与数据库的读写串行化
  - [ ] 一致性最高的方法
  - [ ] 注意
    - [ ] 1）仅适用于对一致性有高要求的场景；
    - [ ] 2）会严重降低系统的吞吐量，需要更多的机器来保证性能；
- [ ] 2）先更新数据库 再删除缓存
  - [ ] 最简单的方法
- [ ] 3）将“读数据-更新缓存”的请求写入一个队列
  - [ ] 较为复杂的方法