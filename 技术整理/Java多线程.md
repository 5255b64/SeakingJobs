#### Java多线程

##### 线程和进程

- [ ] 定义：
  - [ ] 进程：程序的一次执行过程，是系统运行程序的基本单位，是系统资源分配的单位；程序（代码）是静态的，进程是动态的；
  - [ ] 线程类似与进程，是更小的程序执行单位；一个进程在执行过程中可以产生多个线程；多个线程共享进程的堆和方法区资源；线程的产生、切换的负担要比进程低，因此也被称为轻量级进程；
- [ ] 区别和优缺点
  - [ ] 进程：开销大；对资源的管理和保护较好；
  - [ ] 线程：开销小；对资源的管理和保护较差；
- [ ] 为什么要使用多线程
  - [ ] 多线程的上下文切换开销低（与多进程相比）；
  - [ ] 多线程可以充分地使用到CPU的多核资源，提高系统的并发能力；
  - [ ] 减少了等待IO时的CPU计算资源浪费；
- [ ] 多线程带来的问题
  - [ ] 内存泄漏；
  - [ ] 上下文切换开销；
  - [ ] 死锁；
  - [ ] 受限于软硬件资源闲置；

##### 线程的五种状态

- [ ] 五种状态
  - [ ] 1）创建
  - [ ] 2）就绪
  - [ ] 3）阻塞
  - [ ] 4）运行
  - [ ] 5）死亡
- [ ] 1）创建状态
  - [ ] 线程做初始化工作；
  - [ ] new了一个Thead对象，但是没有start()；
  - [ ] 调用start()方法之后，进入就绪状态；
- [ ] 2）就绪状态
  - [ ] 线程准备运行，等待CPU资源；
  - [ ] 调用了Thread对象的start()方法；
- [ ] 3）阻塞状态
  - [ ] 线程被挂起；
  - [ ] 挂起原因：sleep、wait；
  - [ ] 阻塞解除之后，进入就绪状态；
- [ ] 4）运行状态
  - [ ] 线程获取到所需资源与CPU资源，运行；
  - [ ] 线程运行完毕或者被中断，会进入死亡状态；
  - [ ] 线程调用sleep()、wait()方法之后，会进入阻塞状态；
  - [ ] CPU时间片用完之后，会进入就绪状态；
- [ ] 5）死亡状态
  - [ ] 线程不再运行，等待被回收；
  - [ ] 死亡的线程，无法再启动；如果再次调用start()方法，则会抛出异常；

##### Java线程的7种状态

- [ ] Thread.State 枚举类 保存了Java线程的6种状态
- [ ] 1）NEW
  - [ ] 就绪态
- [ ] 2）RUNNABLE
  - [ ] 运行态
- [ ] 3）BLOCKED
  - [ ] 阻塞态，被阻塞等待监视器锁定的线程处于此状态；
- [ ] 4）WAITING
  - [ ] 阻塞态，正在等待另一个线程执行特定动作的线程，处于此状态；
- [ ] 5）TIMED_WAITING
  - [ ] 阻塞态，正在等待另一个县城执行动作达到指定等待时间的线程处于此状态；
- [ ] 6）TERMINATED
  - [ ] 终止态，已退出的线程；

##### 停止线程的方法

- [ ] 不推荐使用JDK的stop()、destory()方法；
- [ ] 推荐让线程把自己停下来；
- [ ] 使用一个标志位（终止变量）使线程停止；

##### 守护线程 daemon

- [ ] 线程分为 用户线程 和 守护线程
- [ ] 用户线程
  - [ ] 虚拟机必须确保用户线程执行完毕；
- [ ] 守护线程
  - [ ] 虚拟机不需要等待守护线程执行完毕；
  - [ ] GC、日志等线程，可以设置为守护线程；

##### 多线程的实现方式 // TODO

- [ ] 线程创建的3种方式

  - [ ] 继承Thread类
  - [ ] 实现Runnable接口
  - [ ] 实现Callable接口

- [ ] 1）Thread

  - [ ] 使用方法
    - [ ] 继承Thread类
    - [ ] 重写run()方法
    - [ ] 调用start()方法 执行线程
  - [ ] Thread本身实现了Runnable接口，可以对Runnable对象进行代理；

- [ ] 2）Runnable

  - [ ] 使用方式：

    - [ ] 创建一个Runnable对象；
    - [ ] 实现Runnable的run()对象；
    - [ ] 以Runnable对象为参数，创建一个Thread对象；（使用Thread进行代理）；
    - [ ] 调用Thread的start()方法；

  - [ ] 局限性：

    - [ ] 使用类，具有单继承的局限性；

  - [ ] 优点：

    - [ ] Runnable是接口，避免单继承的局限性，方便同一个对象被多个线程使用；

    - [ ] 可以使用匿名Thread类；

      ``` java
      Runnable myRunable = new MyRunnable();
      new Thread(myRunable).start();
      ```

      

- [ ] 3）Callable

##### 线程常用方法

- [ ] sleep()
  - [ ] 阻塞线程；
  - [ ] 固定延时之后，线程进入就绪态；
  - [ ] 不会释放锁；
- [ ] yield()
  - [ ] 将当前线程，转换为就绪态；
  - [ ] 相当于sleep(0)
- [ ] join()
  - [ ] 插队；
  - [ ] 阻塞其他线程，当join()的线程执行完之后，将其他线程转为就绪态；

##### 线程同步

- [ ] Java的每个对象，都有一把锁；
- [ ] 多线程同步，可以通过竞争同一个资源的锁来完成；

##### 死锁以及死锁的避免

- [ ] 死锁：指多个线程持有资源，并且同时等待别的线程释放资源，导致无限等待；
- [ ] 死锁的四个必要条件：
  - [ ] 1）互斥条件 该资源同一时间只能由一个线程占用；
  - [ ] 2）请求与保持条件 一个进程因请求资源而阻塞，而对自己已获取的资源未释放；
  - [ ] 3）不剥夺条件 线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只有自己使用完之后才能释放资源；
  - [ ] 4）循环等待条件 若干进程之间形成一种头尾相接的循环等待资源关系；
- [ ] 如何避免死锁：
  - [ ] 1）打破死锁的四个必要条件：
    - [ ] 1.1）破坏互斥条件 
      - [ ] 令资源能够被共享；
      - [ ] 无法达成；
      - [ ] 因为资源必须要互斥访问；
    - [ ] 1.2）破坏请求与保持条件 
      - [ ] 线程一次性申请所有所需的资源，如果部分资源申请不到，则不占用任何资源；
      - [ ] 降低了资源的利用率；
      - [ ] 因为资源可能只在线程生命周期的一段时间内被使用，在其余时间因不被占用；
    - [ ] 1.3）破坏不剥夺条件
      - [ ] 线程因为等待申请其他资源而阻塞时，需要释放掉自己持有的所有资源；
    - [ ] 1.4）破坏循环等待条件
      - [ ] 按序申请资源；
  - [ ] 2）银行家算法
    - [ ] 在分配资源时，防止进入不安全的状态；
    - [ ] 略

##### sleep()与wait()的异同

- [ ] 共同点
  - [ ] 1）两者都可以暂停线程，将线程挂起；
- [ ] 区别
  - [ ] 1）sleep()不会释放锁，而wait()会释放锁；
  - [ ] 2）wait用户线程间的交互和通信，由别的线程调用自己的wait();sleep()通常用于暂停执行；
  - [ ] 3）sleep()调用后，线程会自动苏醒；wait()调用后，线程无法自动苏醒，而需要别的对象调用该对象的notify()或者notifyAll()方法；

##### 为什么使用start()而不是run()

- [ ] start()的功能，是对线程执行相应的初始化工作，并且抛出新的线程；新线程会执行run()方法；
- [ ] 执行run()方法，仅仅是令主线程执行run()方法中的代码，而没有用到多线程；

##### synchronized关键字

- [ ] synchronized用法：
  - [ ] 1）修饰方法（静态、非静态）

- [ ] 线程调用该方法时，需要先获取锁；

 ```java
   public synchronized static void method() {
 // todo
}
 ```

    - [ ] 修饰静态方法：相当于对类加锁
      
    - [ ] 修饰非静态方法：相当于对对象实例加锁

  - [ ] 2）修饰代码块

    - [ ] 给指定资源加锁；

    - [ ] 需要给定指定资源；通常是变量或者引用量；不要给常量加锁，因为常量可能使用了缓冲池；

    - [ ] 线程执行该代码块时，需要获得指定资源的锁；

      ```java
      public void method3(SomeObject obj)
      {
         //obj 锁定的对象
         synchronized(obj)
         {
            // todo
         }
      }
      ```

      

- [ ] synchronized底层实现

  - [ ] 1）修饰语句块
    - [ ] 在字节码中，使用“monitorenter”和“monitorexit”来标记同步代码块的开始和结束位置；
    - [ ] mornitor对象存在于每个对象的对象头中；mornitor实际就是一个计数器；
  - [ ] 2）修饰方法
    - [ ] 在字节码中，方法的flags字段中增加ACC_SYNCHRONIZED标识；

- [ ] JDK1.6之后 synchronized的优化

  - [ ] 早期的JDK全使用了重量级锁；
  - [ ] JDK1.6之后，引入了大量的优化，锁会随着被调用的情况而进行升级；

- [ ] synchronized和ReentrantLock 的区别

  - [ ] 两者都是可重入锁（递归锁）

##### volatile关键字

- [ ] 使用volatile关键字修饰的变量，每次读取都需要从主存中获取，而不是在缓存或者寄存器中读取；
- [ ] 声明为volatile的变量，JVM会认为它是不稳定的；
- [ ] volatile的主要作用：保证变量的可见性，防止指令重排序（由于缓存与主存不一致，导致结果上的指令执行顺序不一致）；
- [ ] 并发编程的三个重要特性：
  - [ ] 1）原子性
    - [ ] 同步代码块必须是原子操作，要么都执行，要么都不执行；
    - [ ] synchronized保证了原子性
  - [ ] 2）可见性
    - [ ] 当一个共享变量被修改后，对所有的线程来说，都应该是可见的；
    - [ ] volatile保证了可见性；
  - [ ] 3）有序性
    - [ ] 防止编译器即运行期对代码的优化，导致指令重排序；
    - [ ] volatile保证了有序性；

##### volatile与synchronized的区别

- [ ] volatile是线程同步的轻量级实现，性能比synchronized要好；
- [ ] volatile修饰变量，而synchronized修饰方法与代码块；
- [ ] volatile不会导致多线程阻塞，而synchronized会导致多线程阻塞；
- [ ] volatile能保证数据的可见性，而不能保证原子性；synchronized同时能保证可见性与原子性；
- [ ] volatile主要用于保证变量的可见性；synchronized主要用于保证访问资源的同步性；

##### ThreadLocal // TODO

- [ ] 简介：为每一个线程存放线程私有的数据；
- [ ] 线程之间是共享数据的，如果想要为线程保留私有的数据，可以使用ThreadLocal；
- [ ] // TODO

##### 线程池 // TODO

- [ ] 池化技术的好处：
  - [ ] 减少每次获取资源的消耗，提高对资源的利用率；
- [ ] 使用线程池的好处：
  - [ ] 降低资源消耗 通过重复利用已创建的线程，降低创建和销毁线程造成的消耗；
  - [ ] 提高响应速度 任务到达时，可以不需要等待线程的创建，能立即执行；
  - [ ] 提高线程的可管理性 线程是稀缺资源；过多的线程，会消耗系统资源，降低系统的稳定性；使用线程池可以进行统一的分配，调优和监控；